{
  "version": 3,
  "sources": ["../../src/lib/utils.ts", "../../src/lib/labels.ts", "../../src/lib/errors.ts", "../../src/lib/events.ts", "../../src/lib/label-handler.ts", "../../src/prefabs/main.ts"],
  "sourcesContent": ["export function requireNonnull<T>(t: T | undefined | null, errorMessage = () => `Unexpected state: ${String(t)}`): T {\n  if (t == null) throw Error(errorMessage());\n  return t;\n}\n\nexport function strictParseInt(s: string | undefined | null, errorMessage = () => `Unexpected argument: ${String(s)}`): number {\n  const n = parseInt(s ?? \"\");\n  if (isNaN(n)) throw Error(errorMessage());\n  return n;\n}\n\nexport function requireType<T>(\n  o: unknown,\n  t: new (...a: unknown[]) => T,\n  errorMessage = () => `Unexpected type: expected as ${String(t)}, but actual type ${String(o)}`,\n): T {\n  if (o instanceof t) return o;\n  throw Error(errorMessage());\n}\n\nexport function component<T extends HTMLElement = HTMLElement>(id: string | undefined | null, t?: new (...a: unknown[]) => T): T {\n  const i = requireNonnull(id, () => \"Unexpected argument: id is null\");\n  const e = requireNonnull(document.getElementById(i), () => `Element not found: #${i}`);\n  return t ? requireType(e, t) : (e as T);\n}\n\nexport function removeAllChildren(e: HTMLElement): void {\n  while (e.lastChild) e.removeChild(e.lastChild);\n}\n\nexport function humanreadableDistance([direction, distance]: [Direction | null, number]): string {\n  const dir = direction ?? \"\";\n  if (distance < 1000) {\n    return `${dir} ${distance.toString()}m`;\n  }\n  return `${dir} ${(distance / 1000).toFixed(2)}km`;\n}\n\nexport function waitAnimationFrame(): Promise<number> {\n  return new Promise((r) => requestAnimationFrame(r));\n}\n\ninterface EventOffsets {\n  offsetX: number;\n  offsetY: number;\n}\n\nexport async function formatCoords(\n  map: GameMapSize | null,\n  canvas: HTMLCanvasElement,\n  elevation: (coods: GameCoords) => Promise<number | null>,\n  event: EventOffsets | null,\n): Promise<string> {\n  if (!event || !map) return \"E/W: -, N/S: -, Elev: -\";\n\n  const gameCoords = canvasEventToGameCoords(event, map, canvas);\n  if (gameCoords === null) return \"E/W: -, N/S: -, Elev: -\";\n\n  const y = (await elevation(gameCoords)) ?? \"-\";\n  return `E/W: ${gameCoords.x.toString()}, N/S: ${gameCoords.z.toString()}, Elev: ${y.toString()}`;\n}\n\nexport function downloadCanvasPng(fileName: string, canvas: HTMLCanvasElement): void {\n  const a = document.createElement(\"a\");\n  a.download = fileName;\n  a.href = canvas.toDataURL(\"image/png\");\n  a.click();\n}\n\nexport async function sleep(msec: number): Promise<void> {\n  return new Promise((r) => setTimeout(r, msec));\n}\n\nexport function gameMapSize(s: { width: number; height: number }): GameMapSize {\n  return { type: \"game\", ...s };\n}\n\nexport function gameCoords(c: { x: number; z: number }): GameCoords {\n  return { type: \"game\", ...c };\n}\n\n/** Returns null if the event was fired out of the canvas */\nexport function canvasEventToGameCoords(event: EventOffsets, mapSize: GameMapSize, canvasSize: HTMLCanvasElement): GameCoords | null {\n  // in-game scale coords with left-top offset\n  const gx = (event.offsetX * mapSize.width) / canvasSize.width;\n  const gz = (event.offsetY * mapSize.height) / canvasSize.height;\n  if (gx < 0 || gx >= mapSize.width || gz < 0 || gz >= mapSize.height) {\n    return null;\n  }\n\n  // in-game coords (center offset)\n  const x = gx - Math.floor(mapSize.width / 2);\n  const z = Math.floor(mapSize.height / 2) - gz;\n  return gameCoords({ x: Math.round(x), z: Math.round(z) });\n}\n\nexport function threePlaneSize(width: number, height: number): ThreePlaneSize {\n  return { type: \"threePlane\", width, height };\n}\n\nexport function printError(e: unknown): void {\n  console.error(\"%o\", e);\n}\n\nexport async function fetchJson<T>(url: string): Promise<T> {\n  const r = await fetch(url);\n  if (!r.ok) throw Error(`Failed to fetch ${url}: ${r.statusText}`);\n  return (await r.json()) as T;\n}\n\nexport function basename(path: string) {\n  return path.substring(path.lastIndexOf(\"/\") + 1);\n}\n\nexport async function readWholeStream(stream: ReadableStream<Uint8Array>): Promise<Uint8Array> {\n  return new Uint8Array(await new Response(stream).arrayBuffer());\n}\n", "import { fetchJson } from \"./utils\";\n\nexport const LANGUAGES = [\n  \"english\",\n  \"german\",\n  \"spanish\",\n  \"french\",\n  \"italian\",\n  \"japanese\",\n  \"koreana\",\n  \"polish\",\n  \"brazilian\",\n  \"russian\",\n  \"turkish\",\n  \"schinese\",\n  \"tchinese\",\n] as const;\nexport type Language = (typeof LANGUAGES)[number];\n\nconst LANGUAGE_TAGS: { [tag: string]: Language } = {\n  en: \"english\",\n  de: \"german\",\n  es: \"spanish\",\n  fr: \"french\",\n  it: \"italian\",\n  ja: \"japanese\",\n  ko: \"koreana\",\n  pl: \"polish\",\n  pt: \"brazilian\",\n  ru: \"russian\",\n  tr: \"turkish\",\n  \"zh-CN\": \"schinese\",\n  \"zh-TW\": \"tchinese\",\n};\n\nconst FILE_BASE_NAMES = [\"blocks\", \"prefabs\", \"shapes\"] as const;\ntype FileBaseName = (typeof FILE_BASE_NAMES)[number];\n\nexport class LabelHolder {\n  static DEFAULT_LANGUAGE: Language = \"english\";\n\n  #baseUrl: string;\n  #language: Language;\n  #fallbacks: Map<FileBaseName, Promise<Map<string, string>>>;\n  #labels: Map<FileBaseName, Promise<Labels>>;\n\n  constructor(baseUrl: string, navigatorLanguages: readonly string[]) {\n    this.#baseUrl = baseUrl;\n    this.#language = resolveLanguage(navigatorLanguages);\n    this.#fallbacks = new Map(FILE_BASE_NAMES.map((n) => [n, this.#fetchLabelMap(LabelHolder.DEFAULT_LANGUAGE, n)] as const));\n    this.#labels = this.#buildAllLabels();\n  }\n\n  get(fileId: FileBaseName): Promise<Labels> {\n    const labels = this.#labels.get(fileId);\n    if (!labels) throw new Error(`No labels for ${this.#language}/${fileId}`);\n    return labels;\n  }\n\n  set language(lang: Language) {\n    if (lang === this.#language) return;\n    console.log(\"LabelHolder set language: %s -> %s\", this.#language, lang);\n    this.#language = lang;\n    this.#labels = this.#buildAllLabels();\n  }\n\n  #buildAllLabels(): Map<FileBaseName, Promise<Labels>> {\n    return new Map(FILE_BASE_NAMES.map((n) => [n, this.#buildLabels(n)]));\n  }\n\n  async #buildLabels(fileBaseName: FileBaseName): Promise<Labels> {\n    const fallback = this.#fallbacks.get(fileBaseName);\n    if (!fallback) throw new Error(`No fallback for ${this.#language}/${fileBaseName}`);\n    return new Labels(await this.#fetchLabelMap(this.#language, fileBaseName), await fallback);\n  }\n\n  async #fetchLabelMap(language: Language, fileId: FileBaseName): Promise<Map<string, string>> {\n    return new Map(Object.entries(await fetchJson(`${this.#baseUrl}/${language}/${fileId}.json`)));\n  }\n}\n\nexport class Labels {\n  #labels: Map<string, string>;\n  #fallback: Map<string, string>;\n\n  constructor(labels: Map<string, string>, defaultLabels: Map<string, string>) {\n    this.#labels = labels;\n    this.#fallback = defaultLabels;\n  }\n\n  get(key: string): string | undefined {\n    return this.#labels.get(key) ?? this.#fallback.get(key);\n  }\n}\n\nexport function resolveLanguage(languages: readonly string[]): Language {\n  for (const clientTag of languages) {\n    for (const [tag, lang] of Object.entries(LANGUAGE_TAGS)) {\n      if (clientTag.startsWith(tag)) return lang;\n    }\n  }\n  return LabelHolder.DEFAULT_LANGUAGE;\n}\n", "export class MultipleErrors extends Error {\n  #causes;\n  constructor(errors: unknown[]) {\n    super(\"Multiple errors occurred\");\n    this.#causes = errors;\n  }\n\n  get causes() {\n    return this.#causes;\n  }\n}\n", "import { printError } from \"./utils\";\nimport { MultipleErrors } from \"./errors\";\n\nexport type MessageMap<N extends string> = { [K in N]?: object };\nexport type Listener<N extends string, M extends MessageMap<N>> = (m: M) => unknown;\n\nexport class ListenerManager<N extends string, M extends MessageMap<N>> {\n  #listeners: Listener<N, M>[] = [];\n\n  addListener(listener: Listener<N, M>) {\n    this.#listeners.push(listener);\n  }\n\n  removeListener(listener: Listener<N, M>) {\n    const index = this.#listeners.indexOf(listener);\n    if (index >= 0) this.#listeners.splice(index, 1);\n  }\n\n  async dispatch(m: M) {\n    const results = await Promise.allSettled(this.#listeners.map((fn) => fn(m)));\n    const errors = results.flatMap((r) => (r.status === \"rejected\" ? [r.reason as unknown] : []));\n    if (errors.length === 1) throw errors[0];\n    if (errors.length > 1) throw new MultipleErrors(errors);\n  }\n\n  dispatchNoAwait(m: M) {\n    this.dispatch(m).catch(printError);\n  }\n}\n", "import { LANGUAGES, LabelHolder, Language, resolveLanguage } from \"./labels\";\nimport * as events from \"./events\";\n\ninterface Doms {\n  language: HTMLSelectElement;\n}\n\ninterface EventMessage {\n  update: { lang: Language };\n}\n\nexport class LabelHandler {\n  #doms: Doms;\n  #listener = new events.ListenerManager<\"update\", EventMessage>();\n  #holder: LabelHolder;\n\n  constructor(doms: Doms, labelsBaseUrl: string, navigatorLanguages: readonly string[]) {\n    this.#doms = doms;\n    this.#holder = new LabelHolder(labelsBaseUrl, navigatorLanguages);\n    this.#buildSelectOptions(navigatorLanguages);\n    this.#doms.language.addEventListener(\"change\", () => {\n      const lang = this.#doms.language.value as Language;\n      if (lang === localStorage.getItem(\"language\")) return;\n      localStorage.setItem(\"language\", lang);\n      this.holder.language = lang;\n      this.#listener.dispatchNoAwait({ update: { lang } });\n    });\n  }\n\n  #buildSelectOptions(navigatorLanguages: readonly string[]) {\n    const existingLangs = new Set(Array.from(this.#doms.language.options).map((o) => o.value));\n    for (const lang of LANGUAGES) {\n      if (existingLangs.has(lang)) continue;\n      const option = document.createElement(\"option\");\n      option.textContent = lang;\n      this.#doms.language.appendChild(option);\n    }\n\n    const browserLang = localStorage.getItem(\"language\") ?? resolveLanguage(navigatorLanguages);\n    if (this.#doms.language.value !== browserLang) {\n      this.#doms.language.value = browserLang;\n      requestAnimationFrame(() => this.#doms.language.dispatchEvent(new Event(\"change\")));\n    }\n  }\n\n  addListener(fn: (m: EventMessage) => void | Promise<void>) {\n    this.#listener.addListener(fn);\n  }\n\n  get language(): Language {\n    return this.#doms.language.value as Language;\n  }\n\n  get holder(): LabelHolder {\n    return this.#holder;\n  }\n}\n", "import { LabelHandler } from \"../lib/label-handler\";\nimport { Labels } from \"../lib/labels\";\nimport { component, printError } from \"../lib/utils\";\n\nfunction main() {\n  const labelHandler = new LabelHandler({ language: component(\"label_lang\", HTMLSelectElement) }, \"../labels\", navigator.languages);\n  const labelHolder = labelHandler.holder;\n  labelHandler.addListener(async () => {\n    updatePrefabLabels(await labelHolder.get(\"prefabs\"));\n    updateBlockLabels(await labelHolder.get(\"blocks\"), await labelHolder.get(\"shapes\"));\n  });\n\n  // init\n  (async () => {\n    updatePrefabLabels(await labelHolder.get(\"prefabs\"));\n    updateBlockLabels(await labelHolder.get(\"blocks\"), await labelHolder.get(\"shapes\"));\n  })().catch(printError);\n}\n\nfunction updatePrefabLabels(labels: Labels) {\n  const name = document.querySelector(\".prefab_name\")?.textContent?.trim();\n  if (!name) return;\n  const labelEl = document.querySelector(\".prefab_label\");\n  if (!labelEl) return;\n  labelEl.textContent = labels.get(name) ?? \"-\";\n}\n\nfunction updateBlockLabels(blockLabels: Labels, shapeLabels: Labels) {\n  for (const blockEl of component(\"blocks\", HTMLElement).querySelectorAll(\".block\")) {\n    const name = blockEl.querySelector(\".block_name\")?.textContent?.trim();\n    if (!name) continue;\n    const labelEl = blockEl.querySelector(\".block_label\");\n    if (!labelEl) continue;\n    labelEl.textContent = blockLabels.get(name) ?? shapeLabels.get(name) ?? \"-\";\n  }\n}\n\nif (document.readyState === \"loading\") {\n  document.addEventListener(\"DOMContentLoaded\", main);\n} else {\n  main();\n}\n"],
  "mappings": "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",
  "names": ["requireNonnull", "t", "errorMessage", "requireType", "o", "t", "errorMessage", "component", "id", "i", "requireNonnull", "e", "printError", "e", "fetchJson", "url", "r", "LANGUAGES", "LANGUAGE_TAGS", "FILE_BASE_NAMES", "LabelHolder", "_LabelHolder", "#baseUrl", "#language", "#fallbacks", "#labels", "baseUrl", "navigatorLanguages", "resolveLanguage", "n", "#fetchLabelMap", "#buildAllLabels", "fileId", "labels", "lang", "#buildLabels", "fileBaseName", "fallback", "Labels", "language", "fetchJson", "#fallback", "defaultLabels", "key", "languages", "clientTag", "tag", "MultipleErrors", "#causes", "errors", "ListenerManager", "#listeners", "listener", "index", "m", "errors", "fn", "r", "MultipleErrors", "printError", "LabelHandler", "#doms", "#listener", "ListenerManager", "#holder", "doms", "labelsBaseUrl", "navigatorLanguages", "LabelHolder", "#buildSelectOptions", "lang", "existingLangs", "o", "LANGUAGES", "option", "browserLang", "resolveLanguage", "fn", "main", "labelHandler", "LabelHandler", "component", "labelHolder", "updatePrefabLabels", "updateBlockLabels", "printError", "labels", "name", "labelEl", "blockLabels", "shapeLabels", "blockEl"]
}
