{
  "version": 3,
  "sources": ["../../lib/map-files.ts", "../../src/lib/storage.ts", "../../src/lib/utils.ts", "../../src/worker/dtm.ts"],
  "sourcesContent": ["import type * as pngjs from \"pngjs\";\n\n/**\n * pngjs needs to be set depending on the environment.\n *\n * Set \"pngjs\" module if in the Node.js.\n * Set \"pngjs/browser\" module if in the browser.\n */\nlet PNG: typeof pngjs.PNG;\nexport function setPNG(png: typeof pngjs.PNG): void {\n  PNG = png;\n}\n\n/**\n * the `name` is the file name to be stored.\n * the `process` is the function to process the file.\n *\n * the name is optional, if not provided, the original file name will be used.\n */\nconst FILE_PROCESS_RULES = {\n  \"map_info.xml\": {\n    name: \"map_info.xml\",\n    process: copy,\n  },\n  \"biomes.png\": {\n    name: \"biomes.png\",\n    process: repackPng,\n  },\n  \"splat3.png\": {\n    name: \"splat3.png\",\n    process: processSplat3Png,\n  },\n  \"splat3_processed.png\": {\n    name: \"splat3.png\",\n    process: processSplat3Png,\n  },\n  \"splat4.png\": {\n    name: \"splat4.png\",\n    process: processSplat4Png,\n  },\n  \"splat4_processed.png\": {\n    name: \"splat4.png\",\n    process: processSplat4Png,\n  },\n  \"radiation.png\": {\n    name: \"radiation.png\",\n    process: processRadiationPng,\n  },\n  \"prefabs.xml\": {\n    name: \"prefabs.xml\",\n    process: copy,\n  },\n  \"dtm.raw\": {\n    name: \"dtm_block.raw.gz\",\n    process: (i: ReadableStream<Uint8Array>, o: WritableStream<Uint8Array>) => i.pipeThrough(new DtmRawTransformer()).pipeTo(o),\n  },\n} as const;\n\nexport type WorldFileName = keyof typeof FILE_PROCESS_RULES;\nexport type MapFileNameMap<T extends keyof typeof FILE_PROCESS_RULES> = (typeof FILE_PROCESS_RULES)[T][\"name\"];\nexport const MAP_FILE_NAME_MAP = Object.fromEntries(Object.entries(FILE_PROCESS_RULES).map(([k, v]) => [k, v.name])) as {\n  [K in WorldFileName]: MapFileNameMap<K>;\n};\nexport type MapFileName = MapFileNameMap<WorldFileName>;\n\nexport class Processor<T extends keyof typeof FILE_PROCESS_RULES> {\n  #worldFileName: T;\n\n  constructor(worldFileName: T) {\n    this.#worldFileName = worldFileName;\n  }\n\n  get mapFileName(): MapFileNameMap<T> {\n    return FILE_PROCESS_RULES[this.#worldFileName].name;\n  }\n\n  async process(src: ReadableStream<Uint8Array>, dst: WritableStream<Uint8Array>): Promise<void> {\n    await FILE_PROCESS_RULES[this.#worldFileName].process(src, dst);\n  }\n}\n\nexport const WORLD_FILE_NAMES = new Set(Object.keys(FILE_PROCESS_RULES)) as Set<keyof typeof FILE_PROCESS_RULES>;\n\nexport function isWorldFileName(name: string): name is keyof typeof FILE_PROCESS_RULES {\n  return WORLD_FILE_NAMES.has(name as keyof typeof FILE_PROCESS_RULES);\n}\n\nexport const MAP_FILE_NAMES = new Set(Object.values(FILE_PROCESS_RULES).map((v) => v.name));\n\nexport function isMapFileName(name: string): name is MapFileNameMap<WorldFileName> {\n  return MAP_FILE_NAMES.has(name as unknown as (typeof FILE_PROCESS_RULES)[keyof typeof FILE_PROCESS_RULES][\"name\"]);\n}\n\nexport function getMapFileName(name: WorldFileName): MapFileNameMap<WorldFileName> {\n  return FILE_PROCESS_RULES[name].name;\n}\n\n/**\n * The value file name is preferred to be used instead of the key file name.\n */\nexport const PREFER_WORLD_FILE_NAMES = {\n  \"splat3.png\": \"splat3_processed.png\",\n  \"splat4.png\": \"splat4_processed.png\",\n} as const;\n\n/**\n * Filter the file names which are not in the `FILE_PROCESS_RULES`.\n * And filter the file names which are preferred to be used.\n * @param names The file names to be filtered\n * @returns The filtered file names\n */\nexport function filterWorldFileNames(names: string[]): WorldFileName[] {\n  const n = names.filter(isWorldFileName);\n  return n.filter((f) => !n.includes(PREFER_WORLD_FILE_NAMES[f as keyof typeof PREFER_WORLD_FILE_NAMES]));\n}\n\n/**\n * @param name The file name\n * @param files The file names\n * @returns true if the file `name` has the preferred file name in the `files`\n */\nexport function hasPreferWorldFileNameIn(name: string, files: string[]): boolean {\n  return name in PREFER_WORLD_FILE_NAMES && files.includes(PREFER_WORLD_FILE_NAMES[name as keyof typeof PREFER_WORLD_FILE_NAMES]);\n}\n\nexport function getPreferWorldFileName(name: string): string | undefined {\n  return (PREFER_WORLD_FILE_NAMES as Record<string, string>)[name];\n}\n\nfunction copy(i: ReadableStream<Uint8Array>, o: WritableStream<Uint8Array>): Promise<void> {\n  return i.pipeTo(o);\n}\n\nfunction repackPng(i: ReadableStream<Uint8Array>, o: WritableStream<Uint8Array>): Promise<void> {\n  return i.pipeThrough(new RepackPngTransformer()).pipeTo(o);\n}\n\nfunction processSplat3Png(i: ReadableStream<Uint8Array>, o: WritableStream<Uint8Array>): Promise<void> {\n  return i.pipeThrough(new Splat3PngTransformer()).pipeTo(o);\n}\n\nfunction processSplat4Png(i: ReadableStream<Uint8Array>, o: WritableStream<Uint8Array>): Promise<void> {\n  return i.pipeThrough(new Splat4PngTransformer()).pipeTo(o);\n}\n\nfunction processRadiationPng(i: ReadableStream<Uint8Array>, o: WritableStream<Uint8Array>): Promise<void> {\n  return i.pipeThrough(new RadiationPngTransformer()).pipeTo(o);\n}\n\nconst DEFAULT_TRASNFORM_STRATEGY = { highWaterMark: 1024 * 1024 };\nconst DEFAULT_TRASNFORM_STRATEGIES = [DEFAULT_TRASNFORM_STRATEGY, DEFAULT_TRASNFORM_STRATEGY] as const;\n\nclass ComposingTransformer {\n  readable: ReadableStream<Uint8Array>;\n  writable: WritableStream<Uint8Array>;\n  constructor(transformStreams: TransformStream<Uint8Array, Uint8Array>[]) {\n    const { readable, writable } = new TransformStream<Uint8Array, Uint8Array>({}, ...DEFAULT_TRASNFORM_STRATEGIES);\n    this.readable = transformStreams.reduce((r, t) => r.pipeThrough(t), readable);\n    this.writable = writable;\n  }\n}\n\n/**\n * Pick odd bytes which indicate block height\n * raw[i] Sub-Block Height\n * raw[i + 1] Block Height\n */\nclass OddByteTransformer extends TransformStream<Uint8Array, Uint8Array> {\n  constructor() {\n    let nextOffset = 1;\n    super(\n      {\n        transform(chunk, controller) {\n          const buffer = new Uint8Array(\n            chunk.length % 2 === 0 ? chunk.length / 2 : nextOffset === 1 ? (chunk.length - 1) / 2 : (chunk.length + 1) / 2,\n          );\n\n          let i = nextOffset;\n          for (; i < chunk.length; i += 2) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            buffer[(i - nextOffset) / 2] = chunk[i]!;\n          }\n\n          nextOffset = i - chunk.length;\n          controller.enqueue(buffer);\n        },\n      },\n      ...DEFAULT_TRASNFORM_STRATEGIES,\n    );\n  }\n}\n\nclass DtmRawTransformer extends ComposingTransformer {\n  constructor() {\n    super([new OddByteTransformer(), new CompressionStream(\"gzip\")]);\n  }\n}\n\nexport class DtmBlockRawDecompressor extends DecompressionStream implements TransformStream<Uint8Array, Uint8Array> {\n  constructor() {\n    super(\"gzip\");\n  }\n}\n\nclass PngEditingTransfomer extends TransformStream<Uint8Array, Uint8Array> {\n  constructor(copyAndEdit: (src: Uint8Array, dst: Uint8ClampedArray | Uint8Array) => void) {\n    const png = new PNG({ deflateLevel: 9, deflateStrategy: 0 });\n    const { promise: flushPromise, resolve, reject }: PromiseWithResolvers<void> = Promise.withResolvers();\n    super(\n      {\n        start(controller) {\n          png.on(\"parsed\", () => {\n            packPng(png, copyAndEdit, controller)\n              .then(resolve)\n              .catch((e: unknown) => {\n                reject(e);\n              });\n          });\n        },\n        transform(chunk) {\n          png.write(chunk);\n        },\n        flush() {\n          return flushPromise;\n        },\n      },\n      ...DEFAULT_TRASNFORM_STRATEGIES,\n    );\n  }\n}\n\nasync function packPng(\n  png: pngjs.PNG,\n  copyAndEdit: (src: Uint8Array, dst: Uint8Array | Uint8ClampedArray) => void,\n  controller: TransformStreamDefaultController<Uint8Array>,\n): Promise<void> {\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  if (globalThis.OffscreenCanvas) {\n    // Faster png packing using OffscreenCanvas\n    const canvas = new OffscreenCanvas(png.width, png.height);\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const ctx = canvas.getContext(\"2d\")!;\n    const imageData = ctx.createImageData(png.width, png.height);\n    copyAndEdit(png.data, imageData.data);\n    ctx.putImageData(imageData, 0, 0);\n    const blob = await canvas.convertToBlob({ type: \"image/png\" });\n    for await (const chunk of blob.stream()) controller.enqueue(chunk);\n  } else {\n    copyAndEdit(png.data, png.data);\n    return new Promise((resolve, reject) => {\n      png\n        .pack()\n        .on(\"data\", (chunk: Uint8Array) => {\n          controller.enqueue(chunk);\n        })\n        .on(\"error\", reject)\n        .on(\"end\", resolve);\n    });\n  }\n}\n\n/**\n * splat3.png should convert the pixels which:\n *   - black to transparent\n *   - other to non-transparent\n */\nclass Splat3PngTransformer extends PngEditingTransfomer {\n  constructor() {\n    super((src, dst) => {\n      for (let i = 0; i < dst.length; i += 4) {\n        if (src[i] === 0 && src[i + 1] === 0 && src[i + 2] === 0) {\n          dst[i] = 0;\n          dst[i + 1] = 0;\n          dst[i + 2] = 0;\n          dst[i + 3] = 0;\n        } else {\n          /* eslint-disable @typescript-eslint/no-non-null-assertion */\n          dst[i] = src[i]!;\n          dst[i + 1] = src[i + 1]!;\n          dst[i + 2] = src[i + 2]!;\n          /* eslint-enable */\n          dst[i + 3] = 255;\n        }\n      }\n    });\n  }\n}\n\n/**\n * splat4.png/splat4_processed.png should convert the pixels which:\n *   - Black to 100% transparent\n *   - Non-black to non-transparent\n *   - Green to blue because they are water\n *   - rgb(0, 0, 29) to blue for splat4.png not splat4_processed.png\n *     See https://github.com/kui/7dtd-map/issues/103\n */\nclass Splat4PngTransformer extends PngEditingTransfomer {\n  constructor() {\n    super((src, dst) => {\n      for (let i = 0; i < src.length; i += 4) {\n        if (src[i] === 0 && src[i + 1] === 0 && src[i + 2] === 0) {\n          dst[i] = 0;\n          dst[i + 1] = 0;\n          dst[i + 2] = 0;\n          dst[i + 3] = 0;\n        } else if (src[i + 1] === 255 || src[i + 2] === 29) {\n          /* eslint-disable @typescript-eslint/no-non-null-assertion */\n          dst[i] = src[i]!;\n          dst[i + 1] = src[i + 2]!;\n          dst[i + 2] = 255;\n          dst[i + 3] = 255;\n        } else {\n          dst[i] = src[i]!;\n          dst[i + 1] = src[i + 1]!;\n          dst[i + 2] = src[i + 2]!;\n          dst[i + 3] = 255;\n          /* eslint-enable */\n        }\n      }\n    });\n  }\n}\n\n/**\n * radiation.png should convert the pixels which:\n *   - black to 100% transparent\n *   - other to non-transparent\n */\nclass RadiationPngTransformer extends PngEditingTransfomer {\n  constructor() {\n    super((src, dst) => {\n      for (let i = 0; i < src.length; i += 4) {\n        if (src[i] === 0 && src[i + 1] === 0 && src[i + 2] === 0) {\n          dst[i] = 0;\n          dst[i + 1] = 0;\n          dst[i + 2] = 0;\n          dst[i + 3] = 0;\n        } else {\n          /* eslint-disable @typescript-eslint/no-non-null-assertion */\n          dst[i] = src[i]!;\n          dst[i + 1] = src[i + 1]!;\n          dst[i + 2] = src[i + 2]!;\n          /* eslint-enable */\n          dst[i + 3] = 255;\n        }\n      }\n    });\n  }\n}\n\n/**\n * Just to repack the PNG\n */\nclass RepackPngTransformer extends PngEditingTransfomer {\n  constructor() {\n    super((src, dst) => {\n      for (let i = 0; i < src.length; i++) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        dst[i] = src[i]!;\n      }\n    });\n  }\n}\n", "import { MapFileName } from \"../../lib/map-files\";\n\nconst MAPS_DIR = \"maps\";\nconst WORKSPACE_DIR = \"workspace\";\n\nexport async function* listMapDirs(): AsyncIterable<MapDir> {\n  const worlds = await mapsDir();\n  for await (const entry of worlds.values()) {\n    if (entry.kind === \"directory\") {\n      yield new MapDir(entry as FileSystemDirectoryHandle);\n    }\n  }\n}\n\nexport async function mapDir(name: string): Promise<MapDir> {\n  const worlds = await mapsDir();\n  return new MapDir(await worlds.getDirectoryHandle(name, { create: true }));\n}\n\nexport async function workspaceDir(): Promise<MapDir> {\n  const root = await navigator.storage.getDirectory();\n  return new MapDir(await root.getDirectoryHandle(WORKSPACE_DIR, { create: true }));\n}\n\nasync function mapsDir() {\n  const root = await navigator.storage.getDirectory();\n  return root.getDirectoryHandle(MAPS_DIR, { create: true });\n}\n\nexport class MapDir {\n  #dir: FileSystemDirectoryHandle;\n\n  constructor(dir: FileSystemDirectoryHandle) {\n    this.#dir = dir;\n  }\n\n  get name(): string {\n    return this.#dir.name;\n  }\n\n  async put(name: MapFileName, data: ArrayBuffer | Blob | ReadableStream<Uint8Array>) {\n    console.debug(\"put\", name);\n    const file = await this.#dir.getFileHandle(name, { create: true });\n    const writable = await file.createWritable();\n    if (data instanceof ArrayBuffer || data instanceof Blob) {\n      await writable.write(data);\n    } else {\n      await data.pipeTo(writable);\n    }\n    await writable.close();\n  }\n\n  async createWritable(name: MapFileName): Promise<FileSystemWritableFileStream> {\n    const file = await this.#dir.getFileHandle(name, { create: true });\n    return await file.createWritable();\n  }\n\n  async get(name: MapFileName): Promise<File | null> {\n    console.debug(\"get\", name);\n    try {\n      const file = await this.#dir.getFileHandle(name);\n      return await file.getFile();\n    } catch (e: unknown) {\n      if (e instanceof DOMException && e.name === \"NotFoundError\") {\n        return null;\n      }\n      throw e;\n    }\n  }\n\n  async size(name: MapFileName): Promise<number> {\n    const file = await this.#dir.getFileHandle(name);\n    return (await file.getFile()).size;\n  }\n\n  async remove(name: MapFileName) {\n    await this.#dir.removeEntry(name);\n  }\n}\n", "export function requireNonnull<T>(t: T | undefined | null, errorMessage = () => `Unexpected state: ${String(t)}`): T {\n  if (t == null) throw Error(errorMessage());\n  return t;\n}\n\nexport function strictParseInt(s: string | undefined | null, errorMessage = () => `Unexpected argument: ${String(s)}`): number {\n  const n = parseInt(s ?? \"\");\n  if (isNaN(n)) throw Error(errorMessage());\n  return n;\n}\n\nexport function requireType<T>(\n  o: unknown,\n  t: new (...a: unknown[]) => T,\n  errorMessage = () => `Unexpected type: expected as ${String(t)}, but actual type ${String(o)}`,\n): T {\n  if (o instanceof t) return o;\n  throw Error(errorMessage());\n}\n\nexport function component<T extends HTMLElement = HTMLElement>(id: string | undefined | null, t?: new (...a: unknown[]) => T): T {\n  const i = requireNonnull(id, () => \"Unexpected argument: id is null\");\n  const e = requireNonnull(document.getElementById(i), () => `Element not found: #${i}`);\n  return t ? requireType(e, t) : (e as T);\n}\n\nexport function removeAllChildren(e: HTMLElement): void {\n  while (e.lastChild) e.removeChild(e.lastChild);\n}\n\nexport function humanreadableDistance([direction, distance]: [Direction | null, number]): string {\n  const dir = direction ?? \"\";\n  if (distance < 1000) {\n    return `${dir} ${distance.toString()}m`;\n  }\n  return `${dir} ${(distance / 1000).toFixed(2)}km`;\n}\n\nexport function waitAnimationFrame(): Promise<number> {\n  return new Promise((r) => requestAnimationFrame(r));\n}\n\ninterface EventOffsets {\n  offsetX: number;\n  offsetY: number;\n}\n\nexport async function formatCoords(\n  map: GameMapSize | null,\n  canvas: HTMLCanvasElement,\n  elevation: (coods: GameCoords) => Promise<number | null>,\n  event: EventOffsets | null,\n): Promise<string> {\n  if (!event || !map) return \"E/W: -, N/S: -, Elev: -\";\n\n  const gameCoords = canvasEventToGameCoords(event, map, canvas);\n  if (gameCoords === null) return \"E/W: -, N/S: -, Elev: -\";\n\n  const y = (await elevation(gameCoords)) ?? \"-\";\n  return `E/W: ${gameCoords.x.toString()}, N/S: ${gameCoords.z.toString()}, Elev: ${y.toString()}`;\n}\n\nexport function downloadCanvasPng(fileName: string, canvas: HTMLCanvasElement): void {\n  const a = document.createElement(\"a\");\n  a.download = fileName;\n  a.href = canvas.toDataURL(\"image/png\");\n  a.click();\n}\n\nexport async function sleep(msec: number): Promise<void> {\n  return new Promise((r) => setTimeout(r, msec));\n}\n\nexport function gameMapSize(s: { width: number; height: number }): GameMapSize {\n  return { type: \"game\", ...s };\n}\n\nexport function gameCoords(c: { x: number; z: number }): GameCoords {\n  return { type: \"game\", ...c };\n}\n\n/** Returns null if the event was fired out of the canvas */\nexport function canvasEventToGameCoords(event: EventOffsets, mapSize: GameMapSize, canvasSize: HTMLCanvasElement): GameCoords | null {\n  // in-game scale coords with left-top offset\n  const gx = (event.offsetX * mapSize.width) / canvasSize.width;\n  const gz = (event.offsetY * mapSize.height) / canvasSize.height;\n  if (gx < 0 || gx >= mapSize.width || gz < 0 || gz >= mapSize.height) {\n    return null;\n  }\n\n  // in-game coords (center offset)\n  const x = gx - Math.floor(mapSize.width / 2);\n  const z = Math.floor(mapSize.height / 2) - gz;\n  return gameCoords({ x: Math.round(x), z: Math.round(z) });\n}\n\nexport function threePlaneSize(width: number, height: number): ThreePlaneSize {\n  return { type: \"threePlane\", width, height };\n}\n\nexport function printError(e: unknown): void {\n  console.error(\"%o\", e);\n}\n\nexport async function fetchJson<T>(url: string): Promise<T> {\n  const r = await fetch(url);\n  if (!r.ok) throw Error(`Failed to fetch ${url}: ${r.statusText}`);\n  return (await r.json()) as T;\n}\n\nexport function basename(path: string) {\n  return path.substring(path.lastIndexOf(\"/\") + 1);\n}\n\nexport async function readWholeStream(stream: ReadableStream<Uint8Array>): Promise<Uint8Array> {\n  return new Uint8Array(await new Response(stream).arrayBuffer());\n}\n", "import { DtmBlockRawDecompressor } from \"../../lib/map-files\";\nimport * as storage from \"../lib/storage\";\nimport { printError, readWholeStream } from \"../lib/utils\";\n\nexport type OutMessage = null | Uint8Array;\n\nasync function main() {\n  const workspace = await storage.workspaceDir();\n  let msg: OutMessage = null;\n  try {\n    msg = await readDtmBlockRaw(workspace);\n  } catch (e) {\n    printError(e);\n  }\n  postMessage(msg, msg ? [msg.buffer] : []);\n  close();\n}\n\nasync function readDtmBlockRaw(workspace: storage.MapDir): Promise<Uint8Array | null> {\n  const file = await workspace.get(\"dtm_block.raw.gz\");\n  if (!file) return null;\n  return readWholeStream(file.stream().pipeThrough(new DtmBlockRawDecompressor() as TransformStream<Uint8Array, Uint8Array>));\n}\n\nmain().catch(printError);\n"],
  "mappings": "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",
  "names": ["PNG", "FILE_PROCESS_RULES", "copy", "repackPng", "processSplat3Png", "processSplat4Png", "processRadiationPng", "i", "o", "DtmRawTransformer", "MAP_FILE_NAME_MAP", "k", "v", "WORLD_FILE_NAMES", "FILE_PROCESS_RULES", "MAP_FILE_NAMES", "FILE_PROCESS_RULES", "v", "copy", "i", "o", "repackPng", "RepackPngTransformer", "processSplat3Png", "Splat3PngTransformer", "processSplat4Png", "Splat4PngTransformer", "processRadiationPng", "RadiationPngTransformer", "DEFAULT_TRASNFORM_STRATEGY", "DEFAULT_TRASNFORM_STRATEGIES", "ComposingTransformer", "transformStreams", "readable", "writable", "r", "t", "OddByteTransformer", "nextOffset", "chunk", "controller", "buffer", "DtmRawTransformer", "DtmBlockRawDecompressor", "PngEditingTransfomer", "copyAndEdit", "png", "PNG", "flushPromise", "resolve", "reject", "packPng", "e", "canvas", "ctx", "imageData", "blob", "src", "dst", "WORKSPACE_DIR", "workspaceDir", "root", "MapDir", "WORKSPACE_DIR", "MapDir", "#dir", "dir", "name", "data", "writable", "e", "printError", "e", "readWholeStream", "stream", "main", "workspace", "workspaceDir", "msg", "readDtmBlockRaw", "e", "printError", "file", "readWholeStream", "DtmBlockRawDecompressor"]
}
