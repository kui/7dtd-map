{
  "version": 3,
  "sources": ["../../src/lib/utils.ts", "../../src/lib/throttled-invoker.ts", "../../src/lib/labels.ts", "../../src/lib/cache-holder.ts", "../../src/lib/errors.ts", "../../src/lib/events.ts", "../../src/lib/prefab-filter.ts", "../../src/worker/prefabs-filter.ts"],
  "sourcesContent": ["export function requireNonnull<T>(t: T | undefined | null, errorMessage = () => `Unexpected state: ${String(t)}`): T {\n  if (t == null) throw Error(errorMessage());\n  return t;\n}\n\nexport function strictParseInt(s: string | undefined | null, errorMessage = () => `Unexpected argument: ${String(s)}`): number {\n  const n = parseInt(s ?? \"\");\n  if (isNaN(n)) throw Error(errorMessage());\n  return n;\n}\n\nexport function requireType<T>(\n  o: unknown,\n  t: new (...a: unknown[]) => T,\n  errorMessage = () => `Unexpected type: expected as ${String(t)}, but actual type ${String(o)}`,\n): T {\n  if (o instanceof t) return o;\n  throw Error(errorMessage());\n}\n\nexport function component<T extends HTMLElement = HTMLElement>(id: string | undefined | null, t?: new (...a: unknown[]) => T): T {\n  const i = requireNonnull(id, () => \"Unexpected argument: id is null\");\n  const e = requireNonnull(document.getElementById(i), () => `Element not found: #${i}`);\n  return t ? requireType(e, t) : (e as T);\n}\n\nexport function removeAllChildren(e: HTMLElement): void {\n  while (e.lastChild) e.removeChild(e.lastChild);\n}\n\nexport function humanreadableDistance([direction, distance]: [Direction | null, number]): string {\n  const dir = direction ?? \"\";\n  if (distance < 1000) {\n    return `${dir} ${distance.toString()}m`;\n  }\n  return `${dir} ${(distance / 1000).toFixed(2)}km`;\n}\n\nexport function waitAnimationFrame(): Promise<number> {\n  return new Promise((r) => requestAnimationFrame(r));\n}\n\ninterface EventOffsets {\n  offsetX: number;\n  offsetY: number;\n}\n\nexport async function formatCoords(\n  map: GameMapSize | null,\n  canvas: HTMLCanvasElement,\n  elevation: (coods: GameCoords) => Promise<number | null>,\n  event: EventOffsets | null,\n): Promise<string> {\n  if (!event || !map) return \"E/W: -, N/S: -, Elev: -\";\n\n  const gameCoords = canvasEventToGameCoords(event, map, canvas);\n  if (gameCoords === null) return \"E/W: -, N/S: -, Elev: -\";\n\n  const y = (await elevation(gameCoords)) ?? \"-\";\n  return `E/W: ${gameCoords.x.toString()}, N/S: ${gameCoords.z.toString()}, Elev: ${y.toString()}`;\n}\n\nexport function downloadCanvasPng(fileName: string, canvas: HTMLCanvasElement): void {\n  const a = document.createElement(\"a\");\n  a.download = fileName;\n  a.href = canvas.toDataURL(\"image/png\");\n  a.click();\n}\n\nexport async function sleep(msec: number): Promise<void> {\n  return new Promise((r) => setTimeout(r, msec));\n}\n\nexport function gameMapSize(s: { width: number; height: number }): GameMapSize {\n  return { type: \"game\", ...s };\n}\n\nexport function gameCoords(c: { x: number; z: number }): GameCoords {\n  return { type: \"game\", ...c };\n}\n\n/** Returns null if the event was fired out of the canvas */\nexport function canvasEventToGameCoords(event: EventOffsets, mapSize: GameMapSize, canvasSize: HTMLCanvasElement): GameCoords | null {\n  // in-game scale coords with left-top offset\n  const gx = (event.offsetX * mapSize.width) / canvasSize.width;\n  const gz = (event.offsetY * mapSize.height) / canvasSize.height;\n  if (gx < 0 || gx >= mapSize.width || gz < 0 || gz >= mapSize.height) {\n    return null;\n  }\n\n  // in-game coords (center offset)\n  const x = gx - Math.floor(mapSize.width / 2);\n  const z = Math.floor(mapSize.height / 2) - gz;\n  return gameCoords({ x: Math.round(x), z: Math.round(z) });\n}\n\nexport function threePlaneSize(width: number, height: number): ThreePlaneSize {\n  return { type: \"threePlane\", width, height };\n}\n\nexport function printError(e: unknown): void {\n  console.error(\"%o\", e);\n}\n\nexport async function fetchJson<T>(url: string): Promise<T> {\n  const r = await fetch(url);\n  if (!r.ok) throw Error(`Failed to fetch ${url}: ${r.statusText}`);\n  return (await r.json()) as T;\n}\n\nexport function basename(path: string) {\n  return path.substring(path.lastIndexOf(\"/\") + 1);\n}\n\nexport async function readWholeStream(stream: ReadableStream<Uint8Array>): Promise<Uint8Array> {\n  return new Uint8Array(await new Response(stream).arrayBuffer());\n}\n", "import { sleep } from \"./utils\";\n\nexport function throttledInvoker(asyncFunc: () => Promise<void> | void, intervalMs = 100): () => Promise<void> {\n  const workerPromises: Promise<void>[] = [];\n  let lastInvokationAt = 0;\n  return () => {\n    switch (workerPromises.length) {\n      case 0: {\n        const p = (async () => {\n          const now = Date.now();\n          if (now < lastInvokationAt + intervalMs) await sleep(lastInvokationAt + intervalMs - now);\n          lastInvokationAt = Date.now();\n          try {\n            await asyncFunc();\n          } finally {\n            void workerPromises.shift();\n          }\n        })();\n        workerPromises.push(p);\n        return p;\n      }\n      case 1: {\n        const prev = workerPromises[0];\n        const p = (async () => {\n          await prev;\n          await sleep(intervalMs);\n          lastInvokationAt = Date.now();\n          try {\n            await asyncFunc();\n          } finally {\n            void workerPromises.shift();\n          }\n        })();\n        workerPromises.push(p);\n        return p;\n      }\n      case 2:\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return workerPromises[1]!;\n      default:\n        throw Error(`Unexpected state: promiceses=${workerPromises.length.toString()}`);\n    }\n  };\n}\n", "import { fetchJson } from \"./utils\";\n\nexport const LANGUAGES = [\n  \"english\",\n  \"german\",\n  \"spanish\",\n  \"french\",\n  \"italian\",\n  \"japanese\",\n  \"koreana\",\n  \"polish\",\n  \"brazilian\",\n  \"russian\",\n  \"turkish\",\n  \"schinese\",\n  \"tchinese\",\n] as const;\nexport type Language = (typeof LANGUAGES)[number];\n\nconst LANGUAGE_TAGS: { [tag: string]: Language } = {\n  en: \"english\",\n  de: \"german\",\n  es: \"spanish\",\n  fr: \"french\",\n  it: \"italian\",\n  ja: \"japanese\",\n  ko: \"koreana\",\n  pl: \"polish\",\n  pt: \"brazilian\",\n  ru: \"russian\",\n  tr: \"turkish\",\n  \"zh-CN\": \"schinese\",\n  \"zh-TW\": \"tchinese\",\n};\n\nconst FILE_BASE_NAMES = [\"blocks\", \"prefabs\", \"shapes\"] as const;\ntype FileBaseName = (typeof FILE_BASE_NAMES)[number];\n\nexport class LabelHolder {\n  static DEFAULT_LANGUAGE: Language = \"english\";\n\n  #baseUrl: string;\n  #language: Language;\n  #fallbacks: Map<FileBaseName, Promise<Map<string, string>>>;\n  #labels: Map<FileBaseName, Promise<Labels>>;\n\n  constructor(baseUrl: string, navigatorLanguages: readonly string[]) {\n    this.#baseUrl = baseUrl;\n    this.#language = resolveLanguage(navigatorLanguages);\n    this.#fallbacks = new Map(FILE_BASE_NAMES.map((n) => [n, this.#fetchLabelMap(LabelHolder.DEFAULT_LANGUAGE, n)] as const));\n    this.#labels = this.#buildAllLabels();\n  }\n\n  get(fileId: FileBaseName): Promise<Labels> {\n    const labels = this.#labels.get(fileId);\n    if (!labels) throw new Error(`No labels for ${this.#language}/${fileId}`);\n    return labels;\n  }\n\n  set language(lang: Language) {\n    if (lang === this.#language) return;\n    console.log(\"LabelHolder set language: %s -> %s\", this.#language, lang);\n    this.#language = lang;\n    this.#labels = this.#buildAllLabels();\n  }\n\n  #buildAllLabels(): Map<FileBaseName, Promise<Labels>> {\n    return new Map(FILE_BASE_NAMES.map((n) => [n, this.#buildLabels(n)]));\n  }\n\n  async #buildLabels(fileBaseName: FileBaseName): Promise<Labels> {\n    const fallback = this.#fallbacks.get(fileBaseName);\n    if (!fallback) throw new Error(`No fallback for ${this.#language}/${fileBaseName}`);\n    return new Labels(await this.#fetchLabelMap(this.#language, fileBaseName), await fallback);\n  }\n\n  async #fetchLabelMap(language: Language, fileId: FileBaseName): Promise<Map<string, string>> {\n    return new Map(Object.entries(await fetchJson(`${this.#baseUrl}/${language}/${fileId}.json`)));\n  }\n}\n\nexport class Labels {\n  #labels: Map<string, string>;\n  #fallback: Map<string, string>;\n\n  constructor(labels: Map<string, string>, defaultLabels: Map<string, string>) {\n    this.#labels = labels;\n    this.#fallback = defaultLabels;\n  }\n\n  get(key: string): string | undefined {\n    return this.#labels.get(key) ?? this.#fallback.get(key);\n  }\n}\n\nexport function resolveLanguage(languages: readonly string[]): Language {\n  for (const clientTag of languages) {\n    for (const [tag, lang] of Object.entries(LANGUAGE_TAGS)) {\n      if (clientTag.startsWith(tag)) return lang;\n    }\n  }\n  return LabelHolder.DEFAULT_LANGUAGE;\n}\n", "const NO_VALUE = Symbol(\"NO_VALUE\");\ntype NoValue = typeof NO_VALUE;\n\n/**\n * A holder for a cached value.\n *\n * The cache is invalidated after `age` since the last access.\n */\nexport class CacheHolder<T> {\n  #fetcher: () => Promise<T>;\n  #deconstructor: (value: T) => unknown;\n  #age: number;\n\n  #value: T | NoValue = NO_VALUE;\n  #fetchPromise: Promise<T> | null = null;\n  #expirationTimeout: ReturnType<typeof setTimeout> | null = null;\n  #lastInvalidation = Date.now();\n\n  constructor(fetcher: () => Promise<T>, deconstructor: (value: T) => unknown, age = 10000) {\n    this.#fetcher = fetcher;\n    this.#deconstructor = deconstructor;\n    this.#age = age;\n  }\n\n  /**\n   * Get the value from the cache.\n   *\n   * If the value is not in the cache, it is fetched and stored.\n   */\n  async get(): Promise<T> {\n    try {\n      return this.#value === NO_VALUE ? await this.#fetch() : this.#value;\n    } finally {\n      this.#resetTimer();\n    }\n  }\n\n  async #fetch() {\n    if (this.#fetchPromise) return this.#fetchPromise;\n    this.#fetchPromise = this.#fetchUntilNoInvalidation();\n    try {\n      this.#value = await this.#fetchPromise;\n    } finally {\n      this.#fetchPromise = null;\n    }\n    return this.#value;\n  }\n\n  async #fetchUntilNoInvalidation(): Promise<T> {\n    let now: number;\n    let value: T;\n    do {\n      now = Date.now();\n      value = await this.#fetcher();\n    } while (now < this.#lastInvalidation);\n    return value;\n  }\n\n  /**\n   * Invalidate the cache.\n   */\n  invalidate() {\n    if (this.#value !== NO_VALUE) {\n      this.#deconstructor(this.#value);\n      this.#value = NO_VALUE;\n    }\n    if (this.#expirationTimeout) clearTimeout(this.#expirationTimeout);\n    this.#expirationTimeout = null;\n    this.#lastInvalidation = Date.now();\n  }\n\n  #resetTimer() {\n    if (this.#expirationTimeout) clearTimeout(this.#expirationTimeout);\n    this.#expirationTimeout = setTimeout(() => {\n      this.invalidate();\n    }, this.#age);\n  }\n}\n", "export class MultipleErrors extends Error {\n  #causes;\n  constructor(errors: unknown[]) {\n    super(\"Multiple errors occurred\");\n    this.#causes = errors;\n  }\n\n  get causes() {\n    return this.#causes;\n  }\n}\n", "import { printError } from \"./utils\";\nimport { MultipleErrors } from \"./errors\";\n\nexport type MessageMap<N extends string> = { [K in N]?: object };\nexport type Listener<N extends string, M extends MessageMap<N>> = (m: M) => unknown;\n\nexport class ListenerManager<N extends string, M extends MessageMap<N>> {\n  #listeners: Listener<N, M>[] = [];\n\n  addListener(listener: Listener<N, M>) {\n    this.#listeners.push(listener);\n  }\n\n  removeListener(listener: Listener<N, M>) {\n    const index = this.#listeners.indexOf(listener);\n    if (index >= 0) this.#listeners.splice(index, 1);\n  }\n\n  async dispatch(m: M) {\n    const results = await Promise.allSettled(this.#listeners.map((fn) => fn(m)));\n    const errors = results.flatMap((r) => (r.status === \"rejected\" ? [r.reason as unknown] : []));\n    if (errors.length === 1) throw errors[0];\n    if (errors.length > 1) throw new MultipleErrors(errors);\n  }\n\n  dispatchNoAwait(m: M) {\n    this.dispatch(m).catch(printError);\n  }\n}\n", "import { throttledInvoker } from \"./throttled-invoker\";\nimport { LabelHolder, Language } from \"./labels\";\nimport { CacheHolder } from \"./cache-holder\";\nimport * as events from \"./events\";\n\nexport interface EventMessage {\n  update: { prefabs: HighlightedPrefab[]; status: string };\n}\n\nexport class PrefabFilter {\n  #labelHolder: LabelHolder;\n  #blockPrefabCountsHolder: CacheHolder<BlockPrefabCounts>;\n\n  #preFiltereds: Prefab[] = [];\n  #filtered: HighlightedPrefab[] = [];\n  #status = \"\";\n  #listeners = new events.ListenerManager<\"update\", EventMessage>();\n  #preExcluds: RegExp[] = [];\n\n  all: Prefab[] = [];\n  markCoords: GameCoords | null = null;\n  difficulty: NumberRange = { start: 0, end: 5 };\n  prefabFilterRegexp = \"\";\n  blockFilterRegexp = \"\";\n\n  constructor(labelsBaseUrl: string, navigatorLanguages: readonly string[], fetchPrefabBlockCounts: () => Promise<BlockPrefabCounts>) {\n    this.#labelHolder = new LabelHolder(labelsBaseUrl, navigatorLanguages);\n    this.#blockPrefabCountsHolder = new CacheHolder(fetchPrefabBlockCounts, () => {\n      /* do nothing */\n    });\n  }\n\n  set language(lang: Language) {\n    this.#labelHolder.language = lang;\n  }\n\n  set preExcludes(patterns: string[]) {\n    this.#preExcluds = patterns.map((f) => new RegExp(f));\n  }\n\n  update = throttledInvoker(() => this.updateImmediately());\n  async updateImmediately(): Promise<void> {\n    await this.#applyFilter();\n    this.#updateStatus();\n    this.#updateDistance();\n    this.#sort();\n    await this.#listeners.dispatch({ update: { status: this.#status, prefabs: this.#filtered } });\n  }\n\n  #updateStatus() {\n    if (\n      this.prefabFilterRegexp.length === 0 &&\n      this.blockFilterRegexp.length === 0 &&\n      this.difficulty.start === 0 &&\n      this.difficulty.end === 5\n    ) {\n      this.#status = `All ${this.#preFiltereds.length.toString()} prefabs`;\n    } else if (this.#filtered.length === 0) {\n      this.#status = \"No prefabs matched\";\n    } else {\n      this.#status = `${this.#filtered.length.toString()} prefabs matched`;\n    }\n  }\n\n  addListener(fn: (m: EventMessage) => unknown) {\n    this.#listeners.addListener(fn);\n  }\n\n  async #applyFilter() {\n    this.#preFiltereds = this.#preMatch(this.all);\n    let result = this.#matchByDifficulty(this.#preFiltereds);\n    result = await this.#matchByPrefabName(result);\n    result = await this.#matchByBlockName(result);\n    this.#filtered = result;\n  }\n\n  #preMatch(prefabs: Prefab[]) {\n    return prefabs.filter((p) => {\n      for (const filter of this.#preExcluds) if (filter.test(p.name)) return false;\n      return true;\n    });\n  }\n\n  #matchByDifficulty(prefabs: Prefab[]): Prefab[] {\n    return prefabs.filter((p) => {\n      const d = p.difficulty ?? 0;\n      return d >= this.difficulty.start && d <= this.difficulty.end;\n    });\n  }\n\n  async #matchByPrefabName(prefabs: Prefab[]): Promise<HighlightedPrefab[]> {\n    const labels = await this.#labelHolder.get(\"prefabs\");\n    const pattern = new RegExp(this.prefabFilterRegexp, \"i\");\n    return prefabs.flatMap<HighlightedPrefab>((prefab) => {\n      const label = labels.get(prefab.name);\n      if (this.prefabFilterRegexp.length === 0) {\n        return {\n          ...prefab,\n          highlightedName: prefab.name,\n          highlightedLabel: label ?? \"-\",\n        };\n      }\n\n      const highlightedName = matchAndHighlight(prefab.name, pattern);\n      const highlightedLabel = label && matchAndHighlight(label, pattern);\n      if (highlightedName != null || highlightedLabel != null) {\n        return {\n          ...prefab,\n          highlightedName: highlightedName ?? prefab.name,\n          highlightedLabel: highlightedLabel ?? label ?? \"-\",\n        };\n      }\n\n      return [];\n    });\n  }\n\n  async #matchByBlockName(prefabs: Prefab[]): Promise<HighlightedPrefab[]> {\n    if (this.blockFilterRegexp.length === 0) {\n      return prefabs;\n    }\n    const matchedPrefabNames = await this.#matchPrefabTypesByBlockName(prefabs);\n    return prefabs.flatMap((prefab) => {\n      const matchedBlocks = matchedPrefabNames[prefab.name];\n      return matchedBlocks ? { ...prefab, matchedBlocks } : [];\n    });\n  }\n\n  async #matchPrefabTypesByBlockName(prefabs: Prefab[]) {\n    const blockLabels = await this.#labelHolder.get(\"blocks\");\n    const shapeLabels = await this.#labelHolder.get(\"shapes\");\n    const prefabNames = new Set(prefabs.map((p) => p.name));\n    const matchedPrefabNames: { [prefabName: string]: HighlightedBlock[] } = {};\n    const pattern = new RegExp(this.blockFilterRegexp, \"i\");\n    for (const [blockName, prefabs] of Object.entries(await this.#blockPrefabCountsHolder.get())) {\n      const highlightedName = matchAndHighlight(blockName, pattern);\n      const label = blockLabels.get(blockName) ?? shapeLabels.get(blockName) ?? \"-\";\n      const highlightedLabel = label && matchAndHighlight(label, pattern);\n      if (highlightedName == null && highlightedLabel == null) continue;\n      for (const [prefabName, count] of Object.entries(prefabs)) {\n        if (!prefabNames.has(prefabName)) continue;\n        matchedPrefabNames[prefabName] = (matchedPrefabNames[prefabName] ?? []).concat({\n          name: blockName,\n          highlightedName: highlightedName ?? blockName,\n          highlightedLabel: highlightedLabel ?? label,\n          count,\n        });\n      }\n    }\n    return matchedPrefabNames;\n  }\n\n  #updateDistance() {\n    if (this.markCoords) {\n      const { markCoords } = this;\n      this.#filtered.forEach((p) => (p.distance = [computeDirection(p, markCoords), computeDistance(p, markCoords)]));\n    } else {\n      this.#filtered.forEach((p) => (p.distance = null));\n    }\n  }\n\n  #sort() {\n    if (this.all.length === 0) {\n      this.#status = \"No prefabs loaded\";\n    } else if (this.#filtered.length === 0) {\n      this.#status += \". Please relax the filter conditions\";\n    } else if (this.markCoords) {\n      this.#status += \", order by distances from the flag\";\n      this.#filtered.sort(distSorter);\n    } else if (this.blockFilterRegexp.length > 0) {\n      this.#status += \", order by counts of matched blocks\";\n      this.#filtered.sort(blockCountSorter);\n    } else {\n      this.#filtered.sort(nameSorter);\n    }\n  }\n}\n\nfunction nameSorter(a: { name: string; difficulty?: number }, b: { name: string; difficulty?: number }) {\n  const aDifficulty = a.difficulty ?? 0;\n  const bDifficulty = b.difficulty ?? 0;\n  if (aDifficulty === bDifficulty) return a.name.localeCompare(b.name);\n  return bDifficulty - aDifficulty;\n}\n\nfunction blockCountSorter(a: HighlightedPrefab, b: HighlightedPrefab) {\n  if (!a.matchedBlocks || !b.matchedBlocks) return nameSorter(a, b);\n  const aCount = a.matchedBlocks.reduce((acc, b) => acc + (b.count ?? 0), 0);\n  const bCount = b.matchedBlocks.reduce((acc, b) => acc + (b.count ?? 0), 0);\n  if (aCount === bCount) return nameSorter(a, b);\n  return bCount - aCount;\n}\n\nfunction distSorter(a: HighlightedPrefab, b: HighlightedPrefab) {\n  if (!a.distance || !b.distance || a.distance[1] === b.distance[1]) return nameSorter(a, b);\n  return a.distance[1] - b.distance[1];\n}\n\nfunction computeDistance(targetCoords: GameCoords, baseCoords: GameCoords) {\n  return Math.round(Math.sqrt((targetCoords.x - baseCoords.x) ** 2 + (targetCoords.z - baseCoords.z) ** 2));\n}\n\nfunction computeDirection(targetCoords: GameCoords, baseCoords: GameCoords): Direction | null {\n  const dx = targetCoords.x - baseCoords.x;\n  const dz = targetCoords.z - baseCoords.z;\n  if (dx === 0 && dz === 0) return null;\n  const angle = (Math.atan2(dz, dx) * 180) / Math.PI;\n  if (angle < -157.5 || angle >= 157.5) return \"W\";\n  if (angle < -112.5) return \"SW\";\n  if (angle < -67.5) return \"S\";\n  if (angle < -22.5) return \"SE\";\n  if (angle < 22.5) return \"E\";\n  if (angle < 67.5) return \"NE\";\n  if (angle < 112.5) return \"N\";\n  return \"NW\";\n}\n\nfunction matchAndHighlight(str: string, regex: RegExp) {\n  let isMatched = false;\n  const highlighted = str.replace(regex, (m) => {\n    isMatched = m.length > 0;\n    return `<mark>${m}</mark>`;\n  });\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  return isMatched ? highlighted : null;\n}\n", "import { PrefabFilter, EventMessage } from \"../lib/prefab-filter\";\nimport { printError, fetchJson } from \"../lib/utils\";\n\nexport type InMessage = Partial<\n  Pick<PrefabFilter, \"all\" | \"difficulty\" | \"prefabFilterRegexp\" | \"blockFilterRegexp\" | \"markCoords\" | \"language\" | \"preExcludes\">\n>;\nexport type OutMessage = EventMessage;\n\nconst prefabs = new PrefabFilter(\"../labels\", navigator.languages, async () =>\n  invertCounts(await fetchJson(\"../prefab-block-counts.json\")),\n);\n\nonmessage = ({ data }: MessageEvent<InMessage>) => {\n  console.log(\"Prefab-filter received message: \", data);\n  Object.assign(prefabs, data).update().catch(printError);\n};\n\nprefabs.addListener((m) => {\n  console.log(\"Prefab-filter send message: \", m);\n  postMessage(m);\n});\n\nfunction invertCounts(counts: PrefabBlockCounts): BlockPrefabCounts {\n  const blockPrefabCounts: BlockPrefabCounts = {};\n  for (const [prefabName, blockCounts] of Object.entries(counts))\n    for (const [blockName, count] of Object.entries(blockCounts))\n      blockPrefabCounts[blockName] = Object.assign(blockPrefabCounts[blockName] ?? {}, { [prefabName]: count });\n  return blockPrefabCounts;\n}\n"],
  "mappings": "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",
  "names": ["sleep", "msec", "r", "printError", "e", "fetchJson", "url", "r", "throttledInvoker", "asyncFunc", "intervalMs", "workerPromises", "lastInvokationAt", "p", "now", "sleep", "prev", "LANGUAGE_TAGS", "FILE_BASE_NAMES", "LabelHolder", "_LabelHolder", "#baseUrl", "#language", "#fallbacks", "#labels", "baseUrl", "navigatorLanguages", "resolveLanguage", "n", "#fetchLabelMap", "#buildAllLabels", "fileId", "labels", "lang", "#buildLabels", "fileBaseName", "fallback", "Labels", "language", "fetchJson", "#fallback", "defaultLabels", "key", "languages", "clientTag", "tag", "NO_VALUE", "CacheHolder", "#fetcher", "#deconstructor", "#age", "#value", "#fetchPromise", "#expirationTimeout", "#lastInvalidation", "fetcher", "deconstructor", "age", "#fetch", "#resetTimer", "#fetchUntilNoInvalidation", "now", "value", "MultipleErrors", "#causes", "errors", "ListenerManager", "#listeners", "listener", "index", "m", "errors", "fn", "r", "MultipleErrors", "printError", "PrefabFilter", "#labelHolder", "#blockPrefabCountsHolder", "#preFiltereds", "#filtered", "#status", "#listeners", "ListenerManager", "#preExcluds", "labelsBaseUrl", "navigatorLanguages", "fetchPrefabBlockCounts", "LabelHolder", "CacheHolder", "lang", "patterns", "f", "throttledInvoker", "#applyFilter", "#updateStatus", "#updateDistance", "#sort", "fn", "#preMatch", "result", "#matchByDifficulty", "#matchByPrefabName", "#matchByBlockName", "prefabs", "p", "filter", "d", "labels", "pattern", "prefab", "label", "highlightedName", "matchAndHighlight", "highlightedLabel", "matchedPrefabNames", "#matchPrefabTypesByBlockName", "matchedBlocks", "blockLabels", "shapeLabels", "prefabNames", "blockName", "prefabName", "count", "markCoords", "computeDirection", "computeDistance", "distSorter", "blockCountSorter", "nameSorter", "a", "b", "aDifficulty", "bDifficulty", "aCount", "acc", "bCount", "targetCoords", "baseCoords", "dx", "dz", "angle", "str", "regex", "isMatched", "highlighted", "m", "prefabs", "PrefabFilter", "invertCounts", "fetchJson", "data", "printError", "m", "counts", "blockPrefabCounts", "prefabName", "blockCounts", "blockName", "count"]
}
