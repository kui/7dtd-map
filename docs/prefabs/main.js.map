{
  "version": 3,
  "sources": ["../../src/lib/utils.ts", "../../src/lib/labels.ts", "../../src/lib/label-handler.ts", "../../src/prefabs/main.ts"],
  "sourcesContent": ["export function requireNonnull<T>(t: T | undefined | null, errorMessage = () => `Unexpected state: ${String(t)}`): T {\n  if (t == null) throw Error(errorMessage());\n  return t;\n}\n\nexport function strictParseInt(s: string | undefined | null, errorMessage = () => `Unexpected argument: ${String(s)}`): number {\n  const n = parseInt(s ?? \"\");\n  if (isNaN(n)) throw Error(errorMessage());\n  return n;\n}\n\nexport function requireType<T>(\n  o: unknown,\n  t: new (...a: unknown[]) => T,\n  errorMessage = () => `Unexpected type: expected as ${String(t)}, but actual type ${String(o)}`,\n): T {\n  if (o instanceof t) return o;\n  throw Error(errorMessage());\n}\n\nexport function component<T extends HTMLElement = HTMLElement>(id: string | undefined | null, t?: new (...a: unknown[]) => T): T {\n  const i = requireNonnull(id, () => \"Unexpected argument: id is null\");\n  const e = requireNonnull(document.getElementById(i), () => `Element not found: #${i}`);\n  return t ? requireType(e, t) : (e as T);\n}\n\nexport function removeAllChildren(e: HTMLElement): void {\n  while (e.lastChild) e.removeChild(e.lastChild);\n}\n\nexport function humanreadableDistance(d: number): string {\n  if (d < 1000) {\n    return `${d.toString()}m`;\n  }\n  return `${(d / 1000).toFixed(2)}km`;\n}\n\nexport function waitAnimationFrame(): Promise<number> {\n  return new Promise((r) => requestAnimationFrame(r));\n}\n\ninterface EventOffsets {\n  offsetX: number;\n  offsetY: number;\n}\n\nexport async function formatCoords(\n  map: GameMapSize | null,\n  canvas: HTMLCanvasElement,\n  elevation: (coods: GameCoords) => Promise<number | null>,\n  event: EventOffsets | null,\n): Promise<string> {\n  if (!event || !map) return \"E/W: -, N/S: -, Elev: -\";\n\n  const gameCoords = canvasEventToGameCoords(event, map, canvas);\n  if (gameCoords === null) return \"E/W: -, N/S: -, Elev: -\";\n\n  const y = (await elevation(gameCoords)) ?? \"-\";\n  return `E/W: ${gameCoords.x.toString()}, N/S: ${gameCoords.z.toString()}, Elev: ${y.toString()}`;\n}\n\nexport function downloadCanvasPng(fileName: string, canvas: HTMLCanvasElement): void {\n  const a = document.createElement(\"a\");\n  a.download = fileName;\n  a.href = canvas.toDataURL(\"image/png\");\n  a.click();\n}\n\nexport async function sleep(msec: number): Promise<void> {\n  return new Promise((r) => setTimeout(r, msec));\n}\n\nexport function gameMapSize(s: { width: number; height: number }): GameMapSize {\n  return { type: \"game\", ...s };\n}\n\nexport function gameCoords(c: { x: number; z: number }): GameCoords {\n  return { type: \"game\", ...c };\n}\n\n/** Returns null if the event was fired out of the canvas */\nexport function canvasEventToGameCoords(event: EventOffsets, mapSize: GameMapSize, canvasSize: HTMLCanvasElement): GameCoords | null {\n  // in-game scale coords with left-top offset\n  const gx = (event.offsetX * mapSize.width) / canvasSize.width;\n  const gz = (event.offsetY * mapSize.height) / canvasSize.height;\n  if (gx < 0 || gx >= mapSize.width || gz < 0 || gz >= mapSize.height) {\n    return null;\n  }\n\n  // in-game coords (center offset)\n  const x = gx - Math.floor(mapSize.width / 2);\n  const z = Math.floor(mapSize.height / 2) - gz;\n  return gameCoords({ x: Math.round(x), z: Math.round(z) });\n}\n\nexport function threePlaneSize(width: number, height: number): ThreePlaneSize {\n  return { type: \"threePlane\", width, height };\n}\n\nexport function printError(e: unknown): void {\n  console.error(e);\n}\n\nexport async function fetchJson<T>(url: string): Promise<T> {\n  const r = await fetch(url);\n  if (!r.ok) throw Error(`Failed to fetch ${url}: ${r.statusText}`);\n  return (await r.json()) as T;\n}\n\nexport function basename(path: string) {\n  return path.substring(path.lastIndexOf(\"/\") + 1);\n}\n\nexport async function readWholeStream(stream: ReadableStream<Uint8Array>): Promise<Uint8Array> {\n  return new Uint8Array(await new Response(stream).arrayBuffer());\n}\n", "import { fetchJson } from \"./utils\";\n\nexport const LANGUAGES = [\n  \"english\",\n  \"german\",\n  \"spanish\",\n  \"french\",\n  \"italian\",\n  \"japanese\",\n  \"koreana\",\n  \"polish\",\n  \"brazilian\",\n  \"russian\",\n  \"turkish\",\n  \"schinese\",\n  \"tchinese\",\n] as const;\nexport type Language = (typeof LANGUAGES)[number];\n\nconst LANGUAGE_TAGS: { [tag: string]: Language } = {\n  en: \"english\",\n  de: \"german\",\n  es: \"spanish\",\n  fr: \"french\",\n  it: \"italian\",\n  ja: \"japanese\",\n  ko: \"koreana\",\n  pl: \"polish\",\n  pt: \"brazilian\",\n  ru: \"russian\",\n  tr: \"turkish\",\n  \"zh-CN\": \"schinese\",\n  \"zh-TW\": \"tchinese\",\n};\n\nconst FILE_BASE_NAMES = [\"blocks\", \"prefabs\", \"shapes\"] as const;\ntype FileBaseName = (typeof FILE_BASE_NAMES)[number];\n\nexport class LabelHolder {\n  static DEFAULT_LANGUAGE: Language = \"english\";\n\n  #baseUrl: string;\n  #language: Language;\n  #fallbacks: Map<FileBaseName, Promise<Map<string, string>>>;\n  #labels: Map<FileBaseName, Promise<Labels>>;\n\n  constructor(baseUrl: string, navigatorLanguages: readonly string[]) {\n    this.#baseUrl = baseUrl;\n    this.#language = resolveLanguage(navigatorLanguages);\n    this.#fallbacks = new Map(FILE_BASE_NAMES.map((n) => [n, this.#fetchLabelMap(LabelHolder.DEFAULT_LANGUAGE, n)] as const));\n    this.#labels = this.#buildAllLabels();\n  }\n\n  get(fileId: FileBaseName): Promise<Labels> {\n    const labels = this.#labels.get(fileId);\n    if (!labels) throw new Error(`No labels for ${this.#language}/${fileId}`);\n    return labels;\n  }\n\n  set language(lang: Language) {\n    if (lang === this.#language) return;\n    console.log(\"LabelHolder set language: %s -> %s\", this.#language, lang);\n    this.#language = lang;\n    this.#labels = this.#buildAllLabels();\n  }\n\n  #buildAllLabels(): Map<FileBaseName, Promise<Labels>> {\n    return new Map(FILE_BASE_NAMES.map((n) => [n, this.#buildLabels(n)]));\n  }\n\n  async #buildLabels(fileBaseName: FileBaseName): Promise<Labels> {\n    const fallback = this.#fallbacks.get(fileBaseName);\n    if (!fallback) throw new Error(`No fallback for ${this.#language}/${fileBaseName}`);\n    return new Labels(await this.#fetchLabelMap(this.#language, fileBaseName), await fallback);\n  }\n\n  async #fetchLabelMap(language: Language, fileId: FileBaseName): Promise<Map<string, string>> {\n    return new Map(Object.entries(await fetchJson(`${this.#baseUrl}/${language}/${fileId}.json`)));\n  }\n}\n\nexport class Labels {\n  #labels: Map<string, string>;\n  #fallback: Map<string, string>;\n\n  constructor(labels: Map<string, string>, defaultLabels: Map<string, string>) {\n    this.#labels = labels;\n    this.#fallback = defaultLabels;\n  }\n\n  get(key: string): string | undefined {\n    return this.#labels.get(key) ?? this.#fallback.get(key);\n  }\n}\n\nexport function resolveLanguage(languages: readonly string[]): Language {\n  for (const clientTag of languages) {\n    for (const [tag, lang] of Object.entries(LANGUAGE_TAGS)) {\n      if (clientTag.startsWith(tag)) return lang;\n    }\n  }\n  return LabelHolder.DEFAULT_LANGUAGE;\n}\n", "import { LANGUAGES, Language, resolveLanguage } from \"./labels\";\nimport { printError } from \"./utils\";\n\ninterface Doms {\n  language: HTMLSelectElement;\n}\n\nexport class LabelHandler {\n  private doms: Doms;\n  private listener: ((lang: Language) => void | Promise<void>)[] = [];\n\n  constructor(doms: Doms, navigatorLanguages: readonly string[]) {\n    this.doms = doms;\n    this.buildSelectOptions(navigatorLanguages);\n    this.doms.language.addEventListener(\"change\", () => {\n      this.listener.forEach((fn) => {\n        fn(this.doms.language.value as Language)?.catch(printError);\n      });\n    });\n  }\n\n  private buildSelectOptions(navigatorLanguages: readonly string[]) {\n    const existingLangs = new Set(Array.from(this.doms.language.options).map((o) => o.value));\n    for (const lang of LANGUAGES) {\n      if (existingLangs.has(lang)) {\n        continue;\n      }\n      const option = document.createElement(\"option\");\n      option.textContent = lang;\n      this.doms.language.appendChild(option);\n    }\n\n    const browserLang = resolveLanguage(navigatorLanguages);\n    if (this.doms.language.value !== browserLang) {\n      this.doms.language.value = resolveLanguage(navigatorLanguages);\n      requestAnimationFrame(() => this.doms.language.dispatchEvent(new Event(\"change\")));\n    }\n  }\n\n  addListener(fn: (lang: Language) => void | Promise<void>) {\n    this.listener.push(fn);\n  }\n}\n", "import { LabelHandler } from \"../lib/label-handler\";\nimport { LabelHolder, Labels } from \"../lib/labels\";\nimport { component } from \"../lib/utils\";\n\nfunction main() {\n  const labelHolder = new LabelHolder(\"../labels\", navigator.languages);\n  const labelHandler = new LabelHandler({ language: component(\"label_lang\", HTMLSelectElement) }, navigator.languages);\n  labelHandler.addListener(async (lang) => {\n    labelHolder.language = lang;\n    updatePrefabLabels(await labelHolder.get(\"prefabs\"));\n    udpateBlockLabels(await labelHolder.get(\"blocks\"), await labelHolder.get(\"shapes\"));\n  });\n}\n\nfunction updatePrefabLabels(labels: Labels) {\n  const name = document.querySelector(\".prefab_name\")?.textContent?.trim();\n  if (!name) return;\n  const labelEl = document.querySelector(\".prefab_label\");\n  if (!labelEl) return;\n  labelEl.textContent = labels.get(name) ?? \"-\";\n}\n\nfunction udpateBlockLabels(blockLabels: Labels, shapeLabels: Labels) {\n  for (const blockEl of component(\"blocks\", HTMLElement).querySelectorAll(\".block\")) {\n    const name = blockEl.querySelector(\".block_name\")?.textContent?.trim();\n    if (!name) continue;\n    const labelEl = blockEl.querySelector(\".block_label\");\n    if (!labelEl) continue;\n    labelEl.textContent = blockLabels.get(name) ?? shapeLabels.get(name) ?? \"-\";\n  }\n}\n\nif (document.readyState === \"loading\") {\n  document.addEventListener(\"DOMContentLoaded\", main);\n} else {\n  main();\n}\n"],
  "mappings": "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",
  "names": ["requireNonnull", "t", "errorMessage", "requireType", "o", "t", "errorMessage", "component", "id", "i", "requireNonnull", "e", "printError", "e", "fetchJson", "url", "r", "LANGUAGES", "LANGUAGE_TAGS", "FILE_BASE_NAMES", "LabelHolder", "_LabelHolder", "#baseUrl", "#language", "#fallbacks", "#labels", "baseUrl", "navigatorLanguages", "resolveLanguage", "n", "#fetchLabelMap", "#buildAllLabels", "fileId", "labels", "lang", "#buildLabels", "fileBaseName", "fallback", "Labels", "language", "fetchJson", "#fallback", "defaultLabels", "key", "languages", "clientTag", "tag", "LabelHandler", "doms", "navigatorLanguages", "fn", "printError", "existingLangs", "o", "lang", "LANGUAGES", "option", "browserLang", "resolveLanguage", "main", "labelHolder", "LabelHolder", "LabelHandler", "component", "lang", "updatePrefabLabels", "udpateBlockLabels", "labels", "name", "labelEl", "blockLabels", "shapeLabels", "blockEl"]
}
