{
  "version": 3,
  "sources": ["../../src/lib/utils.ts", "../../src/lib/throttled-invoker.ts", "../../src/lib/storage.ts", "../../src/lib/cache-holder.ts", "../../src/lib/map-renderer.ts", "../../src/worker/map-renderer.ts"],
  "sourcesContent": ["export function requireNonnull<T>(t: T | undefined | null, errorMessage = () => `Unexpected state: ${String(t)}`): T {\n  if (t == null) throw Error(errorMessage());\n  return t;\n}\n\nexport function strictParseInt(s: string | undefined | null, errorMessage = () => `Unexpected argument: ${String(s)}`): number {\n  const n = parseInt(s ?? \"\");\n  if (isNaN(n)) throw Error(errorMessage());\n  return n;\n}\n\nexport function requireType<T>(\n  o: unknown,\n  t: new (...a: unknown[]) => T,\n  errorMessage = () => `Unexpected type: expected as ${String(t)}, but actual type ${String(o)}`,\n): T {\n  if (o instanceof t) return o;\n  throw Error(errorMessage());\n}\n\nexport function component<T extends HTMLElement = HTMLElement>(id: string | undefined | null, t?: new (...a: unknown[]) => T): T {\n  const i = requireNonnull(id, () => \"Unexpected argument: id is null\");\n  const e = requireNonnull(document.getElementById(i), () => `Element not found: #${i}`);\n  return t ? requireType(e, t) : (e as T);\n}\n\nexport function removeAllChildren(e: HTMLElement): void {\n  while (e.lastChild) e.removeChild(e.lastChild);\n}\n\nexport function humanreadableDistance(d: number): string {\n  if (d < 1000) {\n    return `${d.toString()}m`;\n  }\n  return `${(d / 1000).toFixed(2)}km`;\n}\n\nexport function waitAnimationFrame(): Promise<number> {\n  return new Promise((r) => requestAnimationFrame(r));\n}\n\ninterface EventOffsets {\n  offsetX: number;\n  offsetY: number;\n}\n\nexport async function formatCoords(\n  map: GameMapSize | null,\n  canvas: HTMLCanvasElement,\n  elevation: (coods: GameCoords) => Promise<number | null>,\n  event: EventOffsets | null,\n): Promise<string> {\n  if (!event || !map) return \"E/W: -, N/S: -, Elev: -\";\n\n  const gameCoords = canvasEventToGameCoords(event, map, canvas);\n  if (gameCoords === null) return \"E/W: -, N/S: -, Elev: -\";\n\n  const y = (await elevation(gameCoords)) ?? \"-\";\n  return `E/W: ${gameCoords.x.toString()}, N/S: ${gameCoords.z.toString()}, Elev: ${y.toString()}`;\n}\n\nexport function downloadCanvasPng(fileName: string, canvas: HTMLCanvasElement): void {\n  const a = document.createElement(\"a\");\n  a.download = fileName;\n  a.href = canvas.toDataURL(\"image/png\");\n  a.click();\n}\n\nexport async function sleep(msec: number): Promise<void> {\n  return new Promise((r) => setTimeout(r, msec));\n}\n\nexport function gameMapSize(s: { width: number; height: number }): GameMapSize {\n  return { type: \"game\", ...s };\n}\n\nexport function gameCoords(c: { x: number; z: number }): GameCoords {\n  return { type: \"game\", ...c };\n}\n\n/** Returns null if the event was fired out of the canvas */\nexport function canvasEventToGameCoords(event: EventOffsets, mapSize: GameMapSize, canvasSize: HTMLCanvasElement): GameCoords | null {\n  // in-game scale coords with left-top offset\n  const gx = (event.offsetX * mapSize.width) / canvasSize.width;\n  const gz = (event.offsetY * mapSize.height) / canvasSize.height;\n  if (gx < 0 || gx >= mapSize.width || gz < 0 || gz >= mapSize.height) {\n    return null;\n  }\n\n  // in-game coords (center offset)\n  const x = gx - Math.floor(mapSize.width / 2);\n  const z = Math.floor(mapSize.height / 2) - gz;\n  return gameCoords({ x: Math.round(x), z: Math.round(z) });\n}\n\nexport function threePlaneSize(width: number, height: number): ThreePlaneSize {\n  return { type: \"threePlane\", width, height };\n}\n\nexport function printError(e: unknown): void {\n  console.error(e);\n}\n\nexport async function fetchJson<T>(url: string): Promise<T> {\n  const r = await fetch(url);\n  if (!r.ok) throw Error(`Failed to fetch ${url}: ${r.statusText}`);\n  return (await r.json()) as T;\n}\n\nexport function basename(path: string) {\n  return path.substring(path.lastIndexOf(\"/\") + 1);\n}\n\nexport async function readWholeStream(stream: ReadableStream<Uint8Array>): Promise<Uint8Array> {\n  return new Uint8Array(await new Response(stream).arrayBuffer());\n}\n", "import { sleep } from \"./utils\";\n\nexport function throttledInvoker(asyncFunc: () => Promise<void> | void, intervalMs = 100): () => Promise<void> {\n  const workerPromises: Promise<void>[] = [];\n  let lastInvokationAt = 0;\n  return () => {\n    switch (workerPromises.length) {\n      case 0: {\n        const p = (async () => {\n          const now = Date.now();\n          if (now < lastInvokationAt + intervalMs) await sleep(lastInvokationAt + intervalMs - now);\n          lastInvokationAt = Date.now();\n          try {\n            await asyncFunc();\n          } finally {\n            void workerPromises.shift();\n          }\n        })();\n        workerPromises.push(p);\n        return p;\n      }\n      case 1: {\n        const prev = workerPromises[0];\n        const p = (async () => {\n          await prev;\n          await sleep(intervalMs);\n          lastInvokationAt = Date.now();\n          try {\n            await asyncFunc();\n          } finally {\n            void workerPromises.shift();\n          }\n        })();\n        workerPromises.push(p);\n        return p;\n      }\n      case 2:\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return workerPromises[1]!;\n      default:\n        throw Error(`Unexpected state: promiceses=${workerPromises.length.toString()}`);\n    }\n  };\n}\n", "import { MapFileName } from \"../../lib/map-files\";\n\nconst MAPS_DIR = \"maps\";\nconst WORKSPACE_DIR = \"workspace\";\n\nexport async function* listMapDirs(): AsyncIterable<MapDir> {\n  const worlds = await mapsDir();\n  for await (const entry of worlds.values()) {\n    if (entry.kind === \"directory\") {\n      yield new MapDir(entry as FileSystemDirectoryHandle);\n    }\n  }\n}\n\nexport async function mapDir(name: string): Promise<MapDir> {\n  const worlds = await mapsDir();\n  return new MapDir(await worlds.getDirectoryHandle(name, { create: true }));\n}\n\nexport async function workspaceDir(): Promise<MapDir> {\n  const root = await navigator.storage.getDirectory();\n  return new MapDir(await root.getDirectoryHandle(WORKSPACE_DIR, { create: true }));\n}\n\nasync function mapsDir() {\n  const root = await navigator.storage.getDirectory();\n  return root.getDirectoryHandle(MAPS_DIR, { create: true });\n}\n\nexport class MapDir {\n  #dir: FileSystemDirectoryHandle;\n\n  constructor(dir: FileSystemDirectoryHandle) {\n    this.#dir = dir;\n  }\n\n  get name(): string {\n    return this.#dir.name;\n  }\n\n  async put(name: MapFileName, data: ArrayBuffer | Blob | ReadableStream<Uint8Array>) {\n    console.debug(\"put\", name);\n    const file = await this.#dir.getFileHandle(name, { create: true });\n    const writable = await file.createWritable();\n    if (data instanceof ArrayBuffer || data instanceof Blob) {\n      await writable.write(data);\n    } else {\n      await data.pipeTo(writable);\n    }\n    await writable.close();\n  }\n\n  async createWritable(name: MapFileName): Promise<FileSystemWritableFileStream> {\n    const file = await this.#dir.getFileHandle(name, { create: true });\n    return await file.createWritable();\n  }\n\n  async get(name: MapFileName): Promise<File | null> {\n    console.debug(\"get\", name);\n    try {\n      const file = await this.#dir.getFileHandle(name);\n      return await file.getFile();\n    } catch (e: unknown) {\n      if (e instanceof DOMException && e.name === \"NotFoundError\") {\n        return null;\n      }\n      throw e;\n    }\n  }\n\n  async size(name: MapFileName): Promise<number> {\n    const file = await this.#dir.getFileHandle(name);\n    return (await file.getFile()).size;\n  }\n\n  async remove(name: MapFileName) {\n    await this.#dir.removeEntry(name);\n  }\n}\n", "const NO_VALUE = Symbol(\"NO_VALUE\");\ntype NoValue = typeof NO_VALUE;\n\n/**\n * A holder for a cached value.\n *\n * The cache is invalidated after `age` since the last access.\n */\nexport class CacheHolder<T> {\n  #fetcher: () => Promise<T>;\n  #deconstructor: (value: T) => unknown;\n  #age: number;\n\n  #value: T | NoValue = NO_VALUE;\n  #fetchPromise: Promise<T> | null = null;\n  #expirationTimeout: ReturnType<typeof setTimeout> | null = null;\n  #lastInvalidation = Date.now();\n\n  constructor(fetcher: () => Promise<T>, deconstructor: (value: T) => unknown, age = 10000) {\n    this.#fetcher = fetcher;\n    this.#deconstructor = deconstructor;\n    this.#age = age;\n  }\n\n  /**\n   * Get the value from the cache.\n   *\n   * If the value is not in the cache, it is fetched and stored.\n   */\n  async get(): Promise<T> {\n    try {\n      return this.#value === NO_VALUE ? this.#fetch() : this.#value;\n    } finally {\n      this.#resetTimer();\n    }\n  }\n\n  async #fetch() {\n    if (this.#fetchPromise) return this.#fetchPromise;\n    this.#fetchPromise = this.#fetchUntilNoInvalidation();\n    try {\n      this.#value = await this.#fetchPromise;\n    } finally {\n      this.#fetchPromise = null;\n    }\n    return this.#value;\n  }\n\n  async #fetchUntilNoInvalidation(): Promise<T> {\n    let now: number;\n    let value: T;\n    do {\n      now = Date.now();\n      value = await this.#fetcher();\n    } while (now < this.#lastInvalidation);\n    return value;\n  }\n\n  /**\n   * Invalidate the cache.\n   */\n  invalidate() {\n    if (this.#value !== NO_VALUE) {\n      this.#deconstructor(this.#value);\n      this.#value = NO_VALUE;\n    }\n    if (this.#expirationTimeout) clearTimeout(this.#expirationTimeout);\n    this.#expirationTimeout = null;\n    this.#lastInvalidation = Date.now();\n  }\n\n  #resetTimer() {\n    if (this.#expirationTimeout) clearTimeout(this.#expirationTimeout);\n    this.#expirationTimeout = setTimeout(() => {\n      this.invalidate();\n    }, this.#age);\n  }\n}\n", "import { throttledInvoker } from \"./throttled-invoker\";\nimport { gameMapSize } from \"./utils\";\nimport * as storage from \"./storage\";\nimport * as mapFiles from \"../../lib/map-files\";\nimport { CacheHolder } from \"./cache-holder\";\n\nconst SIGN_CHAR = \"\u2718\";\nconst MARK_CHAR = \"\uD83D\uDEA9\uFE0F\";\n\nexport default class MapRenderer {\n  brightness = \"100%\";\n  markerCoords: GameCoords | null = null;\n  scale = 0.1;\n  showPrefabs = true;\n  prefabs: HighlightedPrefab[] = [];\n  signSize = 200;\n  signAlpha = 1;\n  biomesAlpha = 1;\n  splat3Alpha = 1;\n  splat4Alpha = 1;\n  radAlpha = 1;\n\n  canvas: OffscreenCanvas;\n  #mapSize = gameMapSize({ width: 0, height: 0 });\n\n  #biomesImage = new BitmapHolder(\"biomes.png\");\n  #splat3Image = new BitmapHolder(\"splat3.png\");\n  #splat4Image = new BitmapHolder(\"splat4.png\");\n  #radImage = new BitmapHolder(\"radiation.png\");\n  #imageFiles = [this.#biomesImage, this.#splat3Image, this.#splat4Image, this.#radImage] as const;\n  #fontFace: FontFace;\n\n  constructor(canvas: OffscreenCanvas, fontFace: FontFace) {\n    this.canvas = canvas;\n    this.#fontFace = fontFace;\n  }\n\n  set invalidate(fileNames: (\"biomes.png\" | \"splat3.png\" | \"splat4.png\" | \"radiation.png\")[]) {\n    for (const fileName of fileNames) {\n      switch (fileName) {\n        case \"biomes.png\":\n          this.#biomesImage.invalidate();\n          break;\n        case \"splat3.png\":\n          this.#splat3Image.invalidate();\n          break;\n        case \"splat4.png\":\n          this.#splat4Image.invalidate();\n          break;\n        case \"radiation.png\":\n          this.#radImage.invalidate();\n          break;\n        default:\n          throw new Error(`Invalid file name: ${String(fileName)}`);\n      }\n    }\n  }\n\n  update = throttledInvoker(async () => {\n    console.log(\"MapUpdate\");\n    console.time(\"MapUpdate\");\n    await this.#updateImmediately();\n    console.timeEnd(\"MapUpdate\");\n  });\n\n  async #updateImmediately(): Promise<void> {\n    const [biomes, splat3, splat4, rad] = await Promise.all(this.#imageFiles.map((i) => i.get()));\n\n    const { width, height } = mapSize(biomes, splat3, splat4, rad);\n    this.#mapSize.width = width;\n    this.#mapSize.height = height;\n    if (width === 0 || height === 0) {\n      this.canvas.width = 1;\n      this.canvas.height = 1;\n      return;\n    }\n\n    this.canvas.width = width * this.scale;\n    this.canvas.height = height * this.scale;\n\n    const context = this.canvas.getContext(\"2d\");\n    if (!context) return;\n    context.scale(this.scale, this.scale);\n    context.filter = `brightness(${this.brightness})`;\n\n    if (biomes && this.biomesAlpha !== 0) {\n      context.globalAlpha = this.biomesAlpha;\n      context.drawImage(biomes, 0, 0, width, height);\n    }\n    if (splat3 && this.splat3Alpha !== 0) {\n      context.globalAlpha = this.splat3Alpha;\n      context.drawImage(splat3, 0, 0, width, height);\n    }\n    if (splat4 && this.splat4Alpha !== 0) {\n      context.globalAlpha = this.splat4Alpha;\n      context.drawImage(splat4, 0, 0, width, height);\n    }\n\n    context.filter = \"none\";\n    if (rad && this.radAlpha !== 0) {\n      context.globalAlpha = this.radAlpha;\n      context.imageSmoothingEnabled = false;\n      context.drawImage(rad, 0, 0, width, height);\n      context.imageSmoothingEnabled = true;\n    }\n\n    context.globalAlpha = this.signAlpha;\n    if (this.showPrefabs) {\n      this.drawPrefabs(context, width, height);\n    }\n    if (this.markerCoords) {\n      this.drawMark(context, width, height);\n    }\n  }\n\n  private drawPrefabs(ctx: OffscreenCanvasRenderingContext2D, width: number, height: number) {\n    ctx.font = `${this.signSize.toString()}px ${this.#fontFace.family}`;\n    ctx.fillStyle = \"red\";\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n\n    const offsetX = width / 2;\n    const offsetY = height / 2;\n\n    const charOffsetX = Math.round(this.signSize * 0.01);\n    const charOffsetY = Math.round(this.signSize * 0.05);\n\n    // Inverted iteration to overwrite signs by higher order prefabs\n    for (const prefab of this.prefabs.toReversed()) {\n      const x = offsetX + prefab.x + charOffsetX;\n      // prefab vertical positions are inverted for canvas coodinates\n      const z = offsetY - prefab.z + charOffsetY;\n      putText(ctx, { text: SIGN_CHAR, x, z, size: this.signSize });\n    }\n  }\n\n  private drawMark(ctx: OffscreenCanvasRenderingContext2D, width: number, height: number) {\n    if (!this.markerCoords) return;\n\n    ctx.font = `${this.signSize.toString()}px ${this.#fontFace.family}`;\n    ctx.fillStyle = \"red\";\n    ctx.textAlign = \"left\";\n    ctx.textBaseline = \"alphabetic\";\n\n    const offsetX = width / 2;\n    const offsetY = height / 2;\n    const charOffsetX = -1 * Math.round(this.signSize * 0.32);\n    const charOffsetY = -1 * Math.round(this.signSize * 0.1);\n\n    const x = offsetX + this.markerCoords.x + charOffsetX;\n    const z = offsetY - this.markerCoords.z + charOffsetY;\n\n    putText(ctx, { text: MARK_CHAR, x, z, size: this.signSize });\n  }\n\n  size(): GameMapSize {\n    return this.#mapSize;\n  }\n}\n\nfunction mapSize(...images: (ImageBitmap | null | undefined)[]): GameMapSize {\n  return gameMapSize({\n    width: Math.max(...images.map((i) => i?.width ?? 0)),\n    height: Math.max(...images.map((i) => i?.height ?? 0)),\n  });\n}\n\ninterface MapSign {\n  text: string;\n  x: number;\n  z: number;\n  size: number;\n}\n\nfunction putText(ctx: OffscreenCanvasRenderingContext2D, { text, x, z, size }: MapSign) {\n  ctx.lineWidth = Math.round(size * 0.2);\n  ctx.strokeStyle = \"rgba(0, 0, 0, 0.8)\";\n  ctx.strokeText(text, x, z);\n\n  ctx.lineWidth = Math.round(size * 0.1);\n  ctx.strokeStyle = \"white\";\n  ctx.strokeText(text, x, z);\n\n  ctx.fillText(text, x, z);\n}\n\nclass BitmapHolder extends CacheHolder<ImageBitmap | null> {\n  constructor(readonly fileName: mapFiles.MapFileName) {\n    super(\n      async () => {\n        console.log(\"Loading image\", fileName);\n        const workspace = await storage.workspaceDir();\n        const file = await workspace.get(fileName);\n        try {\n          return file ? await createImageBitmap(file) : null;\n        } finally {\n          console.log(\"Loaded image\", fileName);\n        }\n      },\n      (img) => img?.close(),\n    );\n  }\n}\n", "import MapRenderer from \"../lib/map-renderer\";\nimport { printError } from \"../lib/utils\";\n\nexport type InMessage = Partial<\n  Pick<\n    MapRenderer,\n    | \"canvas\"\n    | \"biomesAlpha\"\n    | \"splat3Alpha\"\n    | \"splat4Alpha\"\n    | \"radAlpha\"\n    | \"showPrefabs\"\n    | \"brightness\"\n    | \"scale\"\n    | \"signSize\"\n    | \"signAlpha\"\n    | \"prefabs\"\n    | \"markerCoords\"\n    | \"invalidate\"\n  >\n>;\n\nexport interface OutMessage {\n  mapSize: GameMapSize;\n}\n\ndeclare function postMessage(message: OutMessage): void;\n\nconst FONT_FACE = new FontFace(\"Noto Sans\", \"url(../NotoEmoji-Regular.ttf)\");\n\nlet map: MapRenderer | null = null;\n\nFONT_FACE.load()\n  .then(() => {\n    fonts.add(FONT_FACE);\n    return map?.update();\n  })\n  .catch(printError);\n\nonmessage = async (event: MessageEvent<InMessage>) => {\n  const message = event.data;\n  console.log(\"map-renderer: recieved %o\", message);\n  if (!map) {\n    if (message.canvas) {\n      map = new MapRenderer(message.canvas, FONT_FACE);\n    } else {\n      throw Error(\"Unexpected state\");\n    }\n  }\n  await Object.assign(map, message).update();\n  const out = { mapSize: map.size() };\n  console.log(\"map-renderer: sending %o\", out);\n  postMessage(out);\n};\n"],
  "mappings": "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",
  "names": ["sleep", "msec", "r", "gameMapSize", "s", "printError", "e", "throttledInvoker", "asyncFunc", "intervalMs", "workerPromises", "lastInvokationAt", "p", "now", "sleep", "prev", "WORKSPACE_DIR", "workspaceDir", "root", "MapDir", "WORKSPACE_DIR", "MapDir", "#dir", "dir", "name", "data", "writable", "e", "NO_VALUE", "CacheHolder", "#fetcher", "#deconstructor", "#age", "#value", "#fetchPromise", "#expirationTimeout", "#lastInvalidation", "fetcher", "deconstructor", "age", "#fetch", "#resetTimer", "#fetchUntilNoInvalidation", "now", "value", "SIGN_CHAR", "MARK_CHAR", "MapRenderer", "#mapSize", "gameMapSize", "#biomesImage", "BitmapHolder", "#splat3Image", "#splat4Image", "#radImage", "#imageFiles", "#fontFace", "canvas", "fontFace", "fileNames", "fileName", "throttledInvoker", "#updateImmediately", "biomes", "splat3", "splat4", "rad", "i", "width", "height", "mapSize", "context", "ctx", "offsetX", "offsetY", "charOffsetX", "charOffsetY", "prefab", "x", "z", "putText", "images", "text", "size", "CacheHolder", "file", "workspaceDir", "img", "FONT_FACE", "map", "printError", "event", "message", "MapRenderer", "out"]
}
