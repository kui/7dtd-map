{
  "version": 3,
  "sources": ["../../src/lib/utils.ts", "../../src/lib/throttled-invoker.ts", "../../src/lib/labels.ts", "../../src/lib/cache-holder.ts", "../../src/lib/prefabs.ts", "../../src/worker/prefabs-filter.ts"],
  "sourcesContent": ["export function requireNonnull<T>(t: T | undefined | null, errorMessage = () => `Unexpected state: ${String(t)}`): T {\n  if (t == null) throw Error(errorMessage());\n  return t;\n}\n\nexport function strictParseInt(s: string | undefined | null, errorMessage = () => `Unexpected argument: ${String(s)}`): number {\n  const n = parseInt(s ?? \"\");\n  if (isNaN(n)) throw Error(errorMessage());\n  return n;\n}\n\nexport function requireType<T>(\n  o: unknown,\n  t: new (...a: unknown[]) => T,\n  errorMessage = () => `Unexpected type: expected as ${String(t)}, but actual type ${String(o)}`,\n): T {\n  if (o instanceof t) return o;\n  throw Error(errorMessage());\n}\n\nexport function component<T extends HTMLElement = HTMLElement>(id: string | undefined | null, t?: new (...a: unknown[]) => T): T {\n  const i = requireNonnull(id, () => \"Unexpected argument: id is null\");\n  const e = requireNonnull(document.getElementById(i), () => `Element not found: #${i}`);\n  return t ? requireType(e, t) : (e as T);\n}\n\nexport function removeAllChildren(e: HTMLElement): void {\n  while (e.lastChild) e.removeChild(e.lastChild);\n}\n\nexport function humanreadableDistance(d: number): string {\n  if (d < 1000) {\n    return `${d.toString()}m`;\n  }\n  return `${(d / 1000).toFixed(2)}km`;\n}\n\nexport function waitAnimationFrame(): Promise<number> {\n  return new Promise((r) => requestAnimationFrame(r));\n}\n\ninterface EventOffsets {\n  offsetX: number;\n  offsetY: number;\n}\n\nexport async function formatCoords(\n  map: GameMapSize | null,\n  canvas: HTMLCanvasElement,\n  elevation: (coods: GameCoords) => Promise<number | null>,\n  event: EventOffsets | null,\n): Promise<string> {\n  if (!event || !map) return \"E/W: -, N/S: -, Elev: -\";\n\n  const gameCoords = canvasEventToGameCoords(event, map, canvas);\n  if (gameCoords === null) return \"E/W: -, N/S: -, Elev: -\";\n\n  const y = (await elevation(gameCoords)) ?? \"-\";\n  return `E/W: ${gameCoords.x.toString()}, N/S: ${gameCoords.z.toString()}, Elev: ${y.toString()}`;\n}\n\nexport function downloadCanvasPng(fileName: string, canvas: HTMLCanvasElement): void {\n  const a = document.createElement(\"a\");\n  a.download = fileName;\n  a.href = canvas.toDataURL(\"image/png\");\n  a.click();\n}\n\nexport async function sleep(msec: number): Promise<void> {\n  return new Promise((r) => setTimeout(r, msec));\n}\n\nexport function gameMapSize(s: { width: number; height: number }): GameMapSize {\n  return { type: \"game\", ...s };\n}\n\nexport function gameCoords(c: { x: number; z: number }): GameCoords {\n  return { type: \"game\", ...c };\n}\n\n/** Returns null if the event was fired out of the canvas */\nexport function canvasEventToGameCoords(event: EventOffsets, mapSize: GameMapSize, canvasSize: HTMLCanvasElement): GameCoords | null {\n  // in-game scale coords with left-top offset\n  const gx = (event.offsetX * mapSize.width) / canvasSize.width;\n  const gz = (event.offsetY * mapSize.height) / canvasSize.height;\n  if (gx < 0 || gx >= mapSize.width || gz < 0 || gz >= mapSize.height) {\n    return null;\n  }\n\n  // in-game coords (center offset)\n  const x = gx - Math.floor(mapSize.width / 2);\n  const z = Math.floor(mapSize.height / 2) - gz;\n  return gameCoords({ x: Math.round(x), z: Math.round(z) });\n}\n\nexport function threePlaneSize(width: number, height: number): ThreePlaneSize {\n  return { type: \"threePlane\", width, height };\n}\n\nexport function printError(e: unknown): void {\n  console.error(e);\n}\n\nexport async function fetchJson<T>(url: string): Promise<T> {\n  const r = await fetch(url);\n  if (!r.ok) throw Error(`Failed to fetch ${url}: ${r.statusText}`);\n  return (await r.json()) as T;\n}\n\nexport function basename(path: string) {\n  return path.substring(path.lastIndexOf(\"/\") + 1);\n}\n\nexport async function readWholeStream(stream: ReadableStream<Uint8Array>): Promise<Uint8Array> {\n  return new Uint8Array(await new Response(stream).arrayBuffer());\n}\n", "import { sleep } from \"./utils\";\n\nexport function throttledInvoker(asyncFunc: () => Promise<void> | void, intervalMs = 100): () => Promise<void> {\n  const workerPromises: Promise<void>[] = [];\n  let lastInvokationAt = 0;\n  return () => {\n    switch (workerPromises.length) {\n      case 0: {\n        const p = (async () => {\n          const now = Date.now();\n          if (now < lastInvokationAt + intervalMs) await sleep(lastInvokationAt + intervalMs - now);\n          lastInvokationAt = Date.now();\n          try {\n            await asyncFunc();\n          } finally {\n            void workerPromises.shift();\n          }\n        })();\n        workerPromises.push(p);\n        return p;\n      }\n      case 1: {\n        const prev = workerPromises[0];\n        const p = (async () => {\n          await prev;\n          await sleep(intervalMs);\n          lastInvokationAt = Date.now();\n          try {\n            await asyncFunc();\n          } finally {\n            void workerPromises.shift();\n          }\n        })();\n        workerPromises.push(p);\n        return p;\n      }\n      case 2:\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return workerPromises[1]!;\n      default:\n        throw Error(`Unexpected state: promiceses=${workerPromises.length.toString()}`);\n    }\n  };\n}\n", "import { fetchJson } from \"./utils\";\n\nexport const LANGUAGES = [\n  \"english\",\n  \"german\",\n  \"spanish\",\n  \"french\",\n  \"italian\",\n  \"japanese\",\n  \"koreana\",\n  \"polish\",\n  \"brazilian\",\n  \"russian\",\n  \"turkish\",\n  \"schinese\",\n  \"tchinese\",\n] as const;\nexport type Language = (typeof LANGUAGES)[number];\n\nconst LANGUAGE_TAGS: { [tag: string]: Language } = {\n  en: \"english\",\n  de: \"german\",\n  es: \"spanish\",\n  fr: \"french\",\n  it: \"italian\",\n  ja: \"japanese\",\n  ko: \"koreana\",\n  pl: \"polish\",\n  pt: \"brazilian\",\n  ru: \"russian\",\n  tr: \"turkish\",\n  \"zh-CN\": \"schinese\",\n  \"zh-TW\": \"tchinese\",\n};\n\nconst FILE_BASE_NAMES = [\"blocks\", \"prefabs\", \"shapes\"] as const;\ntype FileBaseName = (typeof FILE_BASE_NAMES)[number];\n\nexport class LabelHolder {\n  static DEFAULT_LANGUAGE: Language = \"english\";\n\n  #baseUrl: string;\n  #language: Language;\n  #fallbacks: Map<FileBaseName, Promise<Map<string, string>>>;\n  #labels: Map<FileBaseName, Promise<Labels>>;\n\n  constructor(baseUrl: string, navigatorLanguages: readonly string[]) {\n    this.#baseUrl = baseUrl;\n    this.#language = resolveLanguage(navigatorLanguages);\n    this.#fallbacks = new Map(FILE_BASE_NAMES.map((n) => [n, this.#fetchLabelMap(LabelHolder.DEFAULT_LANGUAGE, n)] as const));\n    this.#labels = this.#buildAllLabels();\n  }\n\n  get(fileId: FileBaseName): Promise<Labels> {\n    const labels = this.#labels.get(fileId);\n    if (!labels) throw new Error(`No labels for ${this.#language}/${fileId}`);\n    return labels;\n  }\n\n  set language(lang: Language) {\n    if (lang === this.#language) return;\n    console.log(\"LabelHolder set language: %s -> %s\", this.#language, lang);\n    this.#language = lang;\n    this.#labels = this.#buildAllLabels();\n  }\n\n  #buildAllLabels(): Map<FileBaseName, Promise<Labels>> {\n    return new Map(FILE_BASE_NAMES.map((n) => [n, this.#buildLabels(n)]));\n  }\n\n  async #buildLabels(fileBaseName: FileBaseName): Promise<Labels> {\n    const fallback = this.#fallbacks.get(fileBaseName);\n    if (!fallback) throw new Error(`No fallback for ${this.#language}/${fileBaseName}`);\n    return new Labels(await this.#fetchLabelMap(this.#language, fileBaseName), await fallback);\n  }\n\n  async #fetchLabelMap(language: Language, fileId: FileBaseName): Promise<Map<string, string>> {\n    return new Map(Object.entries(await fetchJson(`${this.#baseUrl}/${language}/${fileId}.json`)));\n  }\n}\n\nexport class Labels {\n  #labels: Map<string, string>;\n  #fallback: Map<string, string>;\n\n  constructor(labels: Map<string, string>, defaultLabels: Map<string, string>) {\n    this.#labels = labels;\n    this.#fallback = defaultLabels;\n  }\n\n  get(key: string): string | undefined {\n    return this.#labels.get(key) ?? this.#fallback.get(key);\n  }\n}\n\nexport function resolveLanguage(languages: readonly string[]): Language {\n  for (const clientTag of languages) {\n    for (const [tag, lang] of Object.entries(LANGUAGE_TAGS)) {\n      if (clientTag.startsWith(tag)) return lang;\n    }\n  }\n  return LabelHolder.DEFAULT_LANGUAGE;\n}\n", "const NO_VALUE = Symbol(\"NO_VALUE\");\ntype NoValue = typeof NO_VALUE;\n\n/**\n * A holder for a cached value.\n *\n * The cache is invalidated after `age` since the last access.\n */\nexport class CacheHolder<T> {\n  #fetcher: () => Promise<T>;\n  #deconstructor: (value: T) => unknown;\n  #age: number;\n\n  #value: T | NoValue = NO_VALUE;\n  #fetchPromise: Promise<T> | null = null;\n  #expirationTimeout: ReturnType<typeof setTimeout> | null = null;\n  #lastInvalidation = Date.now();\n\n  constructor(fetcher: () => Promise<T>, deconstructor: (value: T) => unknown, age = 10000) {\n    this.#fetcher = fetcher;\n    this.#deconstructor = deconstructor;\n    this.#age = age;\n  }\n\n  /**\n   * Get the value from the cache.\n   *\n   * If the value is not in the cache, it is fetched and stored.\n   */\n  async get(): Promise<T> {\n    try {\n      return this.#value === NO_VALUE ? this.#fetch() : this.#value;\n    } finally {\n      this.#resetTimer();\n    }\n  }\n\n  async #fetch() {\n    if (this.#fetchPromise) return this.#fetchPromise;\n    this.#fetchPromise = this.#fetchUntilNoInvalidation();\n    try {\n      this.#value = await this.#fetchPromise;\n    } finally {\n      this.#fetchPromise = null;\n    }\n    return this.#value;\n  }\n\n  async #fetchUntilNoInvalidation(): Promise<T> {\n    let now: number;\n    let value: T;\n    do {\n      now = Date.now();\n      value = await this.#fetcher();\n    } while (now < this.#lastInvalidation);\n    return value;\n  }\n\n  /**\n   * Invalidate the cache.\n   */\n  invalidate() {\n    if (this.#value !== NO_VALUE) {\n      this.#deconstructor(this.#value);\n      this.#value = NO_VALUE;\n    }\n    if (this.#expirationTimeout) clearTimeout(this.#expirationTimeout);\n    this.#expirationTimeout = null;\n    this.#lastInvalidation = Date.now();\n  }\n\n  #resetTimer() {\n    if (this.#expirationTimeout) clearTimeout(this.#expirationTimeout);\n    this.#expirationTimeout = setTimeout(() => {\n      this.invalidate();\n    }, this.#age);\n  }\n}\n", "import { throttledInvoker } from \"./throttled-invoker\";\nimport { LabelHolder, Language } from \"./labels\";\nimport { CacheHolder } from \"./cache-holder\";\n\nexport interface PrefabUpdate {\n  status: string;\n  prefabs: HighlightedPrefab[];\n}\n\nexport class PrefabFilter {\n  #labelHolder: LabelHolder;\n  #blockPrefabCountsHolder: CacheHolder<BlockPrefabCounts>;\n\n  #filtered: HighlightedPrefab[] = [];\n  #status = \"\";\n  #updateListeners: ((u: PrefabUpdate) => void)[] = [];\n\n  all: Prefab[] = [];\n  markCoords: GameCoords | null = null;\n  difficulty: NumberRange = { start: 0, end: 5 };\n  prefabFilterRegexp = \"\";\n  blockFilterRegexp = \"\";\n\n  constructor(labelsBaseUrl: string, navigatorLanguages: readonly string[], fetchPrefabBlockCounts: () => Promise<BlockPrefabCounts>) {\n    this.#labelHolder = new LabelHolder(labelsBaseUrl, navigatorLanguages);\n    this.#blockPrefabCountsHolder = new CacheHolder(fetchPrefabBlockCounts, () => {\n      /* do nothing */\n    });\n  }\n\n  set language(lang: Language) {\n    this.#labelHolder.language = lang;\n  }\n\n  update = throttledInvoker(() => this.updateImmediately());\n  async updateImmediately(): Promise<void> {\n    await this.#applyFilter();\n    this.#updateStatus();\n    this.#updateDist();\n    this.#sort();\n    const update: PrefabUpdate = { status: this.#status, prefabs: this.#filtered };\n    this.#updateListeners.forEach((f) => {\n      f(update);\n    });\n  }\n\n  #updateStatus() {\n    if (\n      this.prefabFilterRegexp.length === 0 &&\n      this.blockFilterRegexp.length === 0 &&\n      this.difficulty.start === 0 &&\n      this.difficulty.end === 5\n    ) {\n      this.#status = `All ${this.all.length.toString()} prefabs`;\n    } else if (this.#filtered.length === 0) {\n      this.#status = \"No prefabs matched\";\n    } else {\n      this.#status = `${this.#filtered.length.toString()} prefabs matched`;\n    }\n  }\n\n  addUpdateListener(func: (update: PrefabUpdate) => void): void {\n    this.#updateListeners.push(func);\n  }\n\n  async #applyFilter() {\n    let result = this.#matchByDifficulty(this.all);\n    result = await this.#matchByPrefabName(result);\n    result = await this.#matchByBlockName(result);\n    this.#filtered = result;\n  }\n\n  #matchByDifficulty(prefabs: Prefab[]): Prefab[] {\n    return prefabs.filter((p) => {\n      const d = p.difficulty ?? 0;\n      return d >= this.difficulty.start && d <= this.difficulty.end;\n    });\n  }\n\n  async #matchByPrefabName(prefabs: Prefab[]): Promise<HighlightedPrefab[]> {\n    const labels = await this.#labelHolder.get(\"prefabs\");\n    const pattern = new RegExp(this.prefabFilterRegexp, \"i\");\n    return prefabs.flatMap<HighlightedPrefab>((prefab) => {\n      const label = labels.get(prefab.name);\n      if (this.prefabFilterRegexp.length === 0) {\n        return {\n          ...prefab,\n          highlightedName: prefab.name,\n          highlightedLabel: label ?? \"-\",\n        };\n      }\n\n      const highlightedName = matchAndHighlight(prefab.name, pattern);\n      const highlightedLabel = label && matchAndHighlight(label, pattern);\n      if (highlightedName != null || highlightedLabel != null) {\n        return {\n          ...prefab,\n          highlightedName: highlightedName ?? prefab.name,\n          highlightedLabel: highlightedLabel ?? label ?? \"-\",\n        };\n      }\n\n      return [];\n    });\n  }\n\n  async #matchByBlockName(prefabs: Prefab[]): Promise<HighlightedPrefab[]> {\n    if (this.blockFilterRegexp.length === 0) {\n      return prefabs;\n    }\n    const matchedPrefabNames = await this.#matchPrefabTypesByBlockName(prefabs);\n    return prefabs.flatMap((prefab) => {\n      const matchedBlocks = matchedPrefabNames[prefab.name];\n      return matchedBlocks ? { ...prefab, matchedBlocks } : [];\n    });\n  }\n\n  async #matchPrefabTypesByBlockName(prefabs: Prefab[]) {\n    const blockLabels = await this.#labelHolder.get(\"blocks\");\n    const shapeLabels = await this.#labelHolder.get(\"shapes\");\n    const prefabNames = new Set(prefabs.map((p) => p.name));\n    const matchedPrefabNames: { [prefabName: string]: HighlightedBlock[] } = {};\n    const pattern = new RegExp(this.blockFilterRegexp, \"i\");\n    for (const [blockName, prefabs] of Object.entries(await this.#blockPrefabCountsHolder.get())) {\n      const highlightedName = matchAndHighlight(blockName, pattern);\n      const label = blockLabels.get(blockName) ?? shapeLabels.get(blockName) ?? \"-\";\n      const highlightedLabel = label && matchAndHighlight(label, pattern);\n      if (highlightedName == null && highlightedLabel == null) continue;\n      for (const [prefabName, count] of Object.entries(prefabs)) {\n        if (!prefabNames.has(prefabName)) continue;\n        matchedPrefabNames[prefabName] = (matchedPrefabNames[prefabName] ?? []).concat({\n          name: blockName,\n          highlightedName: highlightedName ?? blockName,\n          highlightedLabel: highlightedLabel ?? label,\n          count,\n        });\n      }\n    }\n    return matchedPrefabNames;\n  }\n\n  #updateDist() {\n    if (this.markCoords) {\n      const { markCoords } = this;\n      this.#filtered.forEach((p) => (p.dist = calcDist(p, markCoords)));\n    } else {\n      this.#filtered.forEach((p) => (p.dist = null));\n    }\n  }\n\n  #sort() {\n    if (this.all.length === 0) {\n      this.#status = \"No prefabs loaded\";\n    } else if (this.#filtered.length === 0) {\n      this.#status += \". Please relax the filter conditions\";\n    } else if (this.markCoords) {\n      this.#status += \", order by distances from the flag\";\n      this.#filtered.sort(distSorter);\n    } else if (this.blockFilterRegexp.length > 0) {\n      this.#status += \", order by counts of matched blocks\";\n      this.#filtered.sort(blockCountSorter);\n    } else {\n      this.#filtered.sort(nameSorter);\n    }\n  }\n}\n\nfunction nameSorter(a: { name: string }, b: { name: string }) {\n  if (a.name > b.name) return 1;\n  if (a.name < b.name) return -1;\n  return 0;\n}\n\nfunction blockCountSorter(a: HighlightedPrefab, b: HighlightedPrefab) {\n  if (!a.matchedBlocks || !b.matchedBlocks) return nameSorter(a, b);\n  const aCount = a.matchedBlocks.reduce((acc, b) => acc + (b.count ?? 0), 0);\n  const bCount = b.matchedBlocks.reduce((acc, b) => acc + (b.count ?? 0), 0);\n  if (aCount < bCount) return 1;\n  if (aCount > bCount) return -1;\n  return nameSorter(a, b);\n}\n\nfunction distSorter(a: HighlightedPrefab, b: HighlightedPrefab) {\n  if (!a.dist || !b.dist) return nameSorter(a, b);\n  if (a.dist > b.dist) return 1;\n  if (a.dist < b.dist) return -1;\n  return nameSorter(a, b);\n}\n\nfunction calcDist(targetCoords: GameCoords, baseCoords: GameCoords) {\n  return Math.round(Math.sqrt((targetCoords.x - baseCoords.x) ** 2 + (targetCoords.z - baseCoords.z) ** 2));\n}\n\nfunction matchAndHighlight(str: string, regex: RegExp) {\n  let isMatched = false;\n  const highlighted = str.replace(regex, (m) => {\n    isMatched = m.length > 0;\n    return `<mark>${m}</mark>`;\n  });\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  return isMatched ? highlighted : null;\n}\n", "import { PrefabFilter } from \"../lib/prefabs\";\nimport { printError, fetchJson } from \"../lib/utils\";\n\nexport type InMessage = Partial<\n  Pick<PrefabFilter, \"all\" | \"difficulty\" | \"prefabFilterRegexp\" | \"blockFilterRegexp\" | \"markCoords\" | \"language\">\n>;\n\nconst prefabs = new PrefabFilter(\"../labels\", navigator.languages, async () =>\n  invertCounts(await fetchJson(\"../prefab-block-counts.json\")),\n);\n\nonmessage = ({ data }: MessageEvent<InMessage>) => {\n  console.log(\"Prefab-filter received message: \", data);\n  Object.assign(prefabs, data).update().catch(printError);\n};\n\nprefabs.addUpdateListener((u) => {\n  console.log(\"Prefab-filter send message: \", u);\n  postMessage(u);\n});\n\nfunction invertCounts(counts: PrefabBlockCounts): BlockPrefabCounts {\n  const blockPrefabCounts: BlockPrefabCounts = {};\n  for (const [prefabName, blockCounts] of Object.entries(counts))\n    for (const [blockName, count] of Object.entries(blockCounts))\n      blockPrefabCounts[blockName] = Object.assign(blockPrefabCounts[blockName] ?? {}, { [prefabName]: count });\n  return blockPrefabCounts;\n}\n"],
  "mappings": "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",
  "names": ["sleep", "msec", "r", "printError", "e", "fetchJson", "url", "r", "throttledInvoker", "asyncFunc", "intervalMs", "workerPromises", "lastInvokationAt", "p", "now", "sleep", "prev", "LANGUAGE_TAGS", "FILE_BASE_NAMES", "LabelHolder", "_LabelHolder", "#baseUrl", "#language", "#fallbacks", "#labels", "baseUrl", "navigatorLanguages", "resolveLanguage", "n", "#fetchLabelMap", "#buildAllLabels", "fileId", "labels", "lang", "#buildLabels", "fileBaseName", "fallback", "Labels", "language", "fetchJson", "#fallback", "defaultLabels", "key", "languages", "clientTag", "tag", "NO_VALUE", "CacheHolder", "#fetcher", "#deconstructor", "#age", "#value", "#fetchPromise", "#expirationTimeout", "#lastInvalidation", "fetcher", "deconstructor", "age", "#fetch", "#resetTimer", "#fetchUntilNoInvalidation", "now", "value", "PrefabFilter", "#labelHolder", "#blockPrefabCountsHolder", "#filtered", "#status", "#updateListeners", "labelsBaseUrl", "navigatorLanguages", "fetchPrefabBlockCounts", "LabelHolder", "CacheHolder", "lang", "throttledInvoker", "#applyFilter", "#updateStatus", "#updateDist", "#sort", "update", "f", "func", "result", "#matchByDifficulty", "#matchByPrefabName", "#matchByBlockName", "prefabs", "p", "d", "labels", "pattern", "prefab", "label", "highlightedName", "matchAndHighlight", "highlightedLabel", "matchedPrefabNames", "#matchPrefabTypesByBlockName", "matchedBlocks", "blockLabels", "shapeLabels", "prefabNames", "blockName", "prefabName", "count", "markCoords", "calcDist", "distSorter", "blockCountSorter", "nameSorter", "a", "b", "aCount", "acc", "bCount", "targetCoords", "baseCoords", "str", "regex", "isMatched", "highlighted", "m", "prefabs", "PrefabFilter", "invertCounts", "fetchJson", "data", "printError", "u", "counts", "blockPrefabCounts", "prefabName", "blockCounts", "blockName", "count"]
}
