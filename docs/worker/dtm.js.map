{
  "version": 3,
  "sources": ["../../lib/map-files.ts", "../../src/lib/storage.ts", "../../src/lib/utils.ts", "../../src/worker/dtm.ts"],
  "sourcesContent": ["import type * as pngjs from \"pngjs\";\n\n/**\n * pngjs needs to be set depending on the environment.\n *\n * Set \"pngjs\" module if in the Node.js.\n * Set \"pngjs/browser\" module if in the browser.\n */\nlet PNG: typeof pngjs.PNG;\nexport function setPNG(png: typeof pngjs.PNG): void {\n  PNG = png;\n}\n\n/**\n * the `name` is the file name to be stored.\n * the `process` is the function to process the file.\n *\n * the name is optional, if not provided, the original file name will be used.\n */\nconst FILE_PROCESS_RULES = {\n  \"map_info.xml\": {\n    name: \"map_info.xml\",\n    process: copy,\n  },\n  \"biomes.png\": {\n    name: \"biomes.png\",\n    process: repackPng,\n  },\n  \"splat3.png\": {\n    name: \"splat3.png\",\n    process: processSplat3Png,\n  },\n  \"splat3_processed.png\": {\n    name: \"splat3.png\",\n    process: processSplat3Png,\n  },\n  \"splat4.png\": {\n    name: \"splat4.png\",\n    process: processSplat4Png,\n  },\n  \"splat4_processed.png\": {\n    name: \"splat4.png\",\n    process: processSplat4Png,\n  },\n  \"radiation.png\": {\n    name: \"radiation.png\",\n    process: processRadiationPng,\n  },\n  \"prefabs.xml\": {\n    name: \"prefabs.xml\",\n    process: copy,\n  },\n  \"dtm.raw\": {\n    name: \"dtm_block.raw.gz\",\n    process: (i: ReadableStream<Uint8Array>, o: WritableStream<Uint8Array>) => i.pipeThrough(new DtmRawTransformer()).pipeTo(o),\n  },\n} as const;\n\nexport type WorldFileName = keyof typeof FILE_PROCESS_RULES;\nexport type MapFileNameMap<T extends keyof typeof FILE_PROCESS_RULES> = (typeof FILE_PROCESS_RULES)[T][\"name\"];\nexport const MAP_FILE_NAME_MAP = Object.fromEntries(Object.entries(FILE_PROCESS_RULES).map(([k, v]) => [k, v.name])) as {\n  [K in WorldFileName]: MapFileNameMap<K>;\n};\nexport type MapFileName = MapFileNameMap<WorldFileName>;\n\nexport class MapFileProcessor<T extends keyof typeof FILE_PROCESS_RULES> {\n  #worldFileName: T;\n\n  constructor(worldFileName: T) {\n    this.#worldFileName = worldFileName;\n  }\n\n  get mapFileName(): MapFileNameMap<T> {\n    return FILE_PROCESS_RULES[this.#worldFileName].name;\n  }\n\n  async process(src: ReadableStream<Uint8Array>, dst: WritableStream<Uint8Array>): Promise<void> {\n    await FILE_PROCESS_RULES[this.#worldFileName].process(src, dst);\n  }\n}\n\nexport const WORLD_FILE_NAMES = new Set(Object.keys(FILE_PROCESS_RULES)) as Set<keyof typeof FILE_PROCESS_RULES>;\n\nexport function isWorldFileName(name: string): name is keyof typeof FILE_PROCESS_RULES {\n  return WORLD_FILE_NAMES.has(name as keyof typeof FILE_PROCESS_RULES);\n}\n\nexport const MAP_FILE_NAMES = new Set(Object.values(FILE_PROCESS_RULES).map((v) => v.name));\n\nexport function isMapFileName(name: string): name is MapFileNameMap<WorldFileName> {\n  return MAP_FILE_NAMES.has(name as unknown as (typeof FILE_PROCESS_RULES)[keyof typeof FILE_PROCESS_RULES][\"name\"]);\n}\n\nexport function getMapFileName(name: WorldFileName): MapFileNameMap<WorldFileName> {\n  return FILE_PROCESS_RULES[name].name;\n}\n\n/**\n * The value file name is preferred to be used instead of the key file name.\n */\nconst PREFER_WORLD_FILE_NAMES = {\n  \"splat3.png\": \"splat3_processed.png\",\n  \"splat4.png\": \"splat4_processed.png\",\n} as const;\n\n/**\n * Filter the file names which are not in the `FILE_PROCESS_RULES`.\n * And filter the file names which are preferred to be used.\n * @param names The file names to be filtered\n * @returns The filtered file names\n */\nexport function filterWorldFileNames(names: string[]): WorldFileName[] {\n  const n = names.filter(isWorldFileName);\n  return n.filter((f) => !n.includes(PREFER_WORLD_FILE_NAMES[f as keyof typeof PREFER_WORLD_FILE_NAMES]));\n}\n\n/**\n * @param name The file name\n * @param files The file names\n * @returns true if the file `name` has the preferred file name in the `files`\n */\nexport function hasPreferWorldFileNameIn(name: string, files: string[]): name is keyof typeof PREFER_WORLD_FILE_NAMES {\n  return name in PREFER_WORLD_FILE_NAMES && files.includes(PREFER_WORLD_FILE_NAMES[name as keyof typeof PREFER_WORLD_FILE_NAMES]);\n}\n\nexport function getPreferWorldFileName(\n  name: keyof typeof PREFER_WORLD_FILE_NAMES,\n): (typeof PREFER_WORLD_FILE_NAMES)[keyof typeof PREFER_WORLD_FILE_NAMES] {\n  return PREFER_WORLD_FILE_NAMES[name];\n}\n\nfunction copy(i: ReadableStream<Uint8Array>, o: WritableStream<Uint8Array>): Promise<void> {\n  return i.pipeTo(o);\n}\n\nfunction repackPng(i: ReadableStream<Uint8Array>, o: WritableStream<Uint8Array>): Promise<void> {\n  return i.pipeThrough(new RepackPngTransformer()).pipeTo(o);\n}\n\nfunction processSplat3Png(i: ReadableStream<Uint8Array>, o: WritableStream<Uint8Array>): Promise<void> {\n  return i.pipeThrough(new Splat3PngTransformer()).pipeTo(o);\n}\n\nfunction processSplat4Png(i: ReadableStream<Uint8Array>, o: WritableStream<Uint8Array>): Promise<void> {\n  return i.pipeThrough(new Splat4PngTransformer()).pipeTo(o);\n}\n\nfunction processRadiationPng(i: ReadableStream<Uint8Array>, o: WritableStream<Uint8Array>): Promise<void> {\n  return i.pipeThrough(new RadiationPngTransformer()).pipeTo(o);\n}\n\nconst DEFAULT_TRASNFORM_STRATEGY = { highWaterMark: 1024 * 1024 };\nconst DEFAULT_TRASNFORM_STRATEGIES = [DEFAULT_TRASNFORM_STRATEGY, DEFAULT_TRASNFORM_STRATEGY] as const;\n\nclass ComposingTransformer {\n  readable: ReadableStream<Uint8Array>;\n  writable: WritableStream<Uint8Array>;\n  constructor(transformStreams: TransformStream<Uint8Array, Uint8Array>[]) {\n    const { readable, writable } = new TransformStream<Uint8Array, Uint8Array>({}, ...DEFAULT_TRASNFORM_STRATEGIES);\n    this.readable = transformStreams.reduce((r, t) => r.pipeThrough(t), readable);\n    this.writable = writable;\n  }\n}\n\n/**\n * Pick odd bytes which indicate block height\n * raw[i] Sub-Block Height\n * raw[i + 1] Block Height\n */\nclass OddByteTransformer extends TransformStream<Uint8Array, Uint8Array> {\n  constructor() {\n    let nextOffset = 1;\n    super(\n      {\n        transform(chunk, controller) {\n          const buffer = new Uint8Array(\n            chunk.length % 2 === 0 ? chunk.length / 2 : nextOffset === 1 ? (chunk.length - 1) / 2 : (chunk.length + 1) / 2,\n          );\n\n          let i = nextOffset;\n          for (; i < chunk.length; i += 2) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            buffer[(i - nextOffset) / 2] = chunk[i]!;\n          }\n\n          nextOffset = i - chunk.length;\n          controller.enqueue(buffer);\n        },\n      },\n      ...DEFAULT_TRASNFORM_STRATEGIES,\n    );\n  }\n}\n\nclass DtmRawTransformer extends ComposingTransformer {\n  constructor() {\n    super([new OddByteTransformer(), new CompressionStream(\"gzip\")]);\n  }\n}\n\nexport class DtmBlockRawDecompressor extends DecompressionStream implements TransformStream<Uint8Array, Uint8Array> {\n  constructor() {\n    super(\"gzip\");\n  }\n}\n\nclass PngEditingTransfomer extends TransformStream<Uint8Array, Uint8Array> {\n  constructor(copyAndEdit: (src: Uint8Array, dst: Uint8ClampedArray | Uint8Array) => void) {\n    const png = new PNG({ deflateLevel: 9, deflateStrategy: 0 });\n    const { promise: flushPromise, resolve, reject }: PromiseWithResolvers<void> = Promise.withResolvers();\n    super(\n      {\n        start(controller) {\n          png.on(\"parsed\", () => {\n            packPng(png, copyAndEdit, controller)\n              .then(resolve)\n              .catch((e: unknown) => {\n                reject(e);\n              });\n          });\n        },\n        transform(chunk) {\n          png.write(chunk);\n        },\n        flush() {\n          return flushPromise;\n        },\n      },\n      ...DEFAULT_TRASNFORM_STRATEGIES,\n    );\n  }\n}\n\nasync function packPng(\n  png: pngjs.PNG,\n  copyAndEdit: (src: Uint8Array, dst: Uint8Array | Uint8ClampedArray) => void,\n  controller: TransformStreamDefaultController<Uint8Array>,\n): Promise<void> {\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  if (globalThis.OffscreenCanvas) {\n    // Faster png packing using OffscreenCanvas\n    const canvas = new OffscreenCanvas(png.width, png.height);\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const ctx = canvas.getContext(\"2d\")!;\n    const imageData = ctx.createImageData(png.width, png.height);\n    copyAndEdit(png.data, imageData.data);\n    ctx.putImageData(imageData, 0, 0);\n    const blob = await canvas.convertToBlob({ type: \"image/png\" });\n    for await (const chunk of blob.stream()) controller.enqueue(chunk);\n  } else {\n    copyAndEdit(png.data, png.data);\n    return new Promise((resolve, reject) => {\n      png\n        .pack()\n        .on(\"data\", (chunk: Uint8Array) => {\n          controller.enqueue(chunk);\n        })\n        .on(\"error\", reject)\n        .on(\"end\", resolve);\n    });\n  }\n}\n\n/**\n * splat3.png should convert the pixels which:\n *   - black to transparent\n *   - other to non-transparent\n */\nclass Splat3PngTransformer extends PngEditingTransfomer {\n  constructor() {\n    super((src, dst) => {\n      for (let i = 0; i < dst.length; i += 4) {\n        if (src[i] === 0 && src[i + 1] === 0 && src[i + 2] === 0) {\n          dst[i] = 0;\n          dst[i + 1] = 0;\n          dst[i + 2] = 0;\n          dst[i + 3] = 0;\n        } else {\n          /* eslint-disable @typescript-eslint/no-non-null-assertion */\n          dst[i] = src[i]!;\n          dst[i + 1] = src[i + 1]!;\n          dst[i + 2] = src[i + 2]!;\n          /* eslint-enable */\n          dst[i + 3] = 255;\n        }\n      }\n    });\n  }\n}\n\n/**\n * splat4.png should convert the pixels which:\n *   - black to 100% transparent\n *   - other to non-transparent\n *   - green to blue because they are water\n */\nclass Splat4PngTransformer extends PngEditingTransfomer {\n  constructor() {\n    super((src, dst) => {\n      for (let i = 0; i < src.length; i += 4) {\n        if (src[i] === 0 && src[i + 1] === 0 && src[i + 2] === 0) {\n          dst[i] = 0;\n          dst[i + 1] = 0;\n          dst[i + 2] = 0;\n          dst[i + 3] = 0;\n        } else if (src[i + 1] === 255) {\n          /* eslint-disable @typescript-eslint/no-non-null-assertion */\n          dst[i] = src[i]!;\n          const green = src[i + 1]!;\n          dst[i + 1] = src[i + 2]!;\n          dst[i + 2] = green;\n          dst[i + 3] = 255;\n        } else {\n          dst[i] = src[i]!;\n          dst[i + 1] = src[i + 1]!;\n          dst[i + 2] = src[i + 2]!;\n          dst[i + 3] = 255;\n          /* eslint-enable */\n        }\n      }\n    });\n  }\n}\n\n/**\n * radiation.png should convert the pixels which:\n *   - black to 100% transparent\n *   - other to non-transparent\n */\nclass RadiationPngTransformer extends PngEditingTransfomer {\n  constructor() {\n    super((src, dst) => {\n      for (let i = 0; i < src.length; i += 4) {\n        if (src[i] === 0 && src[i + 1] === 0 && src[i + 2] === 0) {\n          dst[i] = 0;\n          dst[i + 1] = 0;\n          dst[i + 2] = 0;\n          dst[i + 3] = 0;\n        } else {\n          /* eslint-disable @typescript-eslint/no-non-null-assertion */\n          dst[i] = src[i]!;\n          dst[i + 1] = src[i + 1]!;\n          dst[i + 2] = src[i + 2]!;\n          /* eslint-enable */\n          dst[i + 3] = 255;\n        }\n      }\n    });\n  }\n}\n\n/**\n * Just to repack the PNG\n */\nclass RepackPngTransformer extends PngEditingTransfomer {\n  constructor() {\n    super((src, dst) => {\n      for (let i = 0; i < src.length; i++) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        dst[i] = src[i]!;\n      }\n    });\n  }\n}\n", "import { MapFileName } from \"../../lib/map-files\";\n\nconst MAPS_DIR = \"maps\";\nconst WORKSPACE_DIR = \"workspace\";\n\nexport async function* listMapDirs(): AsyncIterable<MapDir> {\n  const worlds = await mapsDir();\n  for await (const entry of worlds.values()) {\n    if (entry.kind === \"directory\") {\n      yield new MapDir(entry as FileSystemDirectoryHandle);\n    }\n  }\n}\n\nexport async function mapDir(name: string): Promise<MapDir> {\n  const worlds = await mapsDir();\n  return new MapDir(await worlds.getDirectoryHandle(name, { create: true }));\n}\n\nexport async function workspaceDir(): Promise<MapDir> {\n  const root = await navigator.storage.getDirectory();\n  return new MapDir(await root.getDirectoryHandle(WORKSPACE_DIR, { create: true }));\n}\n\nasync function mapsDir() {\n  const root = await navigator.storage.getDirectory();\n  return root.getDirectoryHandle(MAPS_DIR, { create: true });\n}\n\nexport class MapDir {\n  #dir: FileSystemDirectoryHandle;\n\n  constructor(dir: FileSystemDirectoryHandle) {\n    this.#dir = dir;\n  }\n\n  get name(): string {\n    return this.#dir.name;\n  }\n\n  async put(name: MapFileName, data: ArrayBuffer | Blob | ReadableStream<Uint8Array>) {\n    console.debug(\"put\", name);\n    const file = await this.#dir.getFileHandle(name, { create: true });\n    const writable = await file.createWritable();\n    if (data instanceof ArrayBuffer || data instanceof Blob) {\n      await writable.write(data);\n    } else {\n      await data.pipeTo(writable);\n    }\n    await writable.close();\n  }\n\n  async createWritable(name: MapFileName): Promise<FileSystemWritableFileStream> {\n    const file = await this.#dir.getFileHandle(name, { create: true });\n    return await file.createWritable();\n  }\n\n  async get(name: MapFileName): Promise<File | null> {\n    console.debug(\"get\", name);\n    try {\n      const file = await this.#dir.getFileHandle(name);\n      return await file.getFile();\n    } catch (e: unknown) {\n      if (e instanceof DOMException && e.name === \"NotFoundError\") {\n        return null;\n      }\n      throw e;\n    }\n  }\n\n  async size(name: MapFileName): Promise<number> {\n    const file = await this.#dir.getFileHandle(name);\n    return (await file.getFile()).size;\n  }\n\n  async remove(name: MapFileName) {\n    await this.#dir.removeEntry(name);\n  }\n}\n", "export function requireNonnull<T>(t: T | undefined | null, errorMessage = () => `Unexpected state: ${String(t)}`): T {\n  if (t == null) throw Error(errorMessage());\n  return t;\n}\n\nexport function strictParseInt(s: string | undefined | null, errorMessage = () => `Unexpected argument: ${String(s)}`): number {\n  const n = parseInt(s ?? \"\");\n  if (isNaN(n)) throw Error(errorMessage());\n  return n;\n}\n\nexport function requireType<T>(\n  o: unknown,\n  t: new (...a: unknown[]) => T,\n  errorMessage = () => `Unexpected type: expected as ${String(t)}, but actual type ${String(o)}`,\n): T {\n  if (o instanceof t) return o;\n  throw Error(errorMessage());\n}\n\nexport function component<T extends HTMLElement = HTMLElement>(id: string | undefined | null, t?: new (...a: unknown[]) => T): T {\n  const i = requireNonnull(id, () => \"Unexpected argument: id is null\");\n  const e = requireNonnull(document.getElementById(i), () => `Element not found: #${i}`);\n  return t ? requireType(e, t) : (e as T);\n}\n\nexport function removeAllChildren(e: HTMLElement): void {\n  while (e.lastChild) e.removeChild(e.lastChild);\n}\n\nexport function humanreadableDistance(d: number): string {\n  if (d < 1000) {\n    return `${d.toString()}m`;\n  }\n  return `${(d / 1000).toFixed(2)}km`;\n}\n\nexport function waitAnimationFrame(): Promise<number> {\n  return new Promise((r) => requestAnimationFrame(r));\n}\n\ninterface EventOffsets {\n  offsetX: number;\n  offsetY: number;\n}\n\nexport async function formatCoords(\n  map: GameMapSize | null,\n  canvas: HTMLCanvasElement,\n  elevation: (coods: GameCoords) => Promise<number | null>,\n  event: EventOffsets | null,\n): Promise<string> {\n  if (!event || !map) return \"E/W: -, N/S: -, Elev: -\";\n\n  const gameCoords = canvasEventToGameCoords(event, map, canvas);\n  if (gameCoords === null) return \"E/W: -, N/S: -, Elev: -\";\n\n  const y = (await elevation(gameCoords)) ?? \"-\";\n  return `E/W: ${gameCoords.x.toString()}, N/S: ${gameCoords.z.toString()}, Elev: ${y.toString()}`;\n}\n\nexport function downloadCanvasPng(fileName: string, canvas: HTMLCanvasElement): void {\n  const a = document.createElement(\"a\");\n  a.download = fileName;\n  a.href = canvas.toDataURL(\"image/png\");\n  a.click();\n}\n\nexport async function sleep(msec: number): Promise<void> {\n  return new Promise((r) => setTimeout(r, msec));\n}\n\nexport function gameMapSize(s: { width: number; height: number }): GameMapSize {\n  return { type: \"game\", ...s };\n}\n\nexport function gameCoords(c: { x: number; z: number }): GameCoords {\n  return { type: \"game\", ...c };\n}\n\n/** Returns null if the event was fired out of the canvas */\nexport function canvasEventToGameCoords(event: EventOffsets, mapSize: GameMapSize, canvasSize: HTMLCanvasElement): GameCoords | null {\n  // in-game scale coords with left-top offset\n  const gx = (event.offsetX * mapSize.width) / canvasSize.width;\n  const gz = (event.offsetY * mapSize.height) / canvasSize.height;\n  if (gx < 0 || gx >= mapSize.width || gz < 0 || gz >= mapSize.height) {\n    return null;\n  }\n\n  // in-game coords (center offset)\n  const x = gx - Math.floor(mapSize.width / 2);\n  const z = Math.floor(mapSize.height / 2) - gz;\n  return gameCoords({ x: Math.round(x), z: Math.round(z) });\n}\n\nexport function threePlaneSize(width: number, height: number): ThreePlaneSize {\n  return { type: \"threePlane\", width, height };\n}\n\nexport function printError(e: unknown): void {\n  console.error(e);\n}\n\nexport async function fetchJson<T>(url: string): Promise<T> {\n  const r = await fetch(url);\n  if (!r.ok) throw Error(`Failed to fetch ${url}: ${r.statusText}`);\n  return (await r.json()) as T;\n}\n\nexport function basename(path: string) {\n  return path.substring(path.lastIndexOf(\"/\") + 1);\n}\n\nexport async function readWholeStream(stream: ReadableStream<Uint8Array>): Promise<Uint8Array> {\n  return new Uint8Array(await new Response(stream).arrayBuffer());\n}\n", "import { DtmBlockRawDecompressor } from \"../../lib/map-files\";\nimport * as storage from \"../lib/storage\";\nimport { printError, readWholeStream } from \"../lib/utils\";\n\nexport type OutMessage = null | Uint8Array;\n\nasync function main() {\n  const workspace = await storage.workspaceDir();\n  let msg: OutMessage = null;\n  try {\n    msg = await readDtmBlockRaw(workspace);\n  } catch (e) {\n    console.error(e);\n  }\n  postMessage(msg, msg ? [msg.buffer] : []);\n  close();\n}\n\nasync function readDtmBlockRaw(workspace: storage.MapDir): Promise<Uint8Array | null> {\n  const file = await workspace.get(\"dtm_block.raw.gz\");\n  if (!file) return null;\n  return readWholeStream(file.stream().pipeThrough(new DtmBlockRawDecompressor() as TransformStream<Uint8Array, Uint8Array>));\n}\n\nmain().catch(printError);\n"],
  "mappings": "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",
  "names": ["PNG", "FILE_PROCESS_RULES", "copy", "repackPng", "processSplat3Png", "processSplat4Png", "processRadiationPng", "i", "o", "DtmRawTransformer", "MAP_FILE_NAME_MAP", "k", "v", "WORLD_FILE_NAMES", "FILE_PROCESS_RULES", "MAP_FILE_NAMES", "FILE_PROCESS_RULES", "v", "copy", "i", "o", "repackPng", "RepackPngTransformer", "processSplat3Png", "Splat3PngTransformer", "processSplat4Png", "Splat4PngTransformer", "processRadiationPng", "RadiationPngTransformer", "DEFAULT_TRASNFORM_STRATEGY", "DEFAULT_TRASNFORM_STRATEGIES", "ComposingTransformer", "transformStreams", "readable", "writable", "r", "t", "OddByteTransformer", "nextOffset", "chunk", "controller", "buffer", "DtmRawTransformer", "DtmBlockRawDecompressor", "PngEditingTransfomer", "copyAndEdit", "png", "PNG", "flushPromise", "resolve", "reject", "packPng", "e", "canvas", "ctx", "imageData", "blob", "src", "dst", "green", "WORKSPACE_DIR", "workspaceDir", "root", "MapDir", "WORKSPACE_DIR", "MapDir", "#dir", "dir", "name", "data", "writable", "e", "printError", "e", "readWholeStream", "stream", "main", "workspace", "workspaceDir", "msg", "readDtmBlockRaw", "e", "file", "readWholeStream", "DtmBlockRawDecompressor", "printError"]
}
