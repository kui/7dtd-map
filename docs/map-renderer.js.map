{"version":3,"sources":["webpack://7dtd-map/./node_modules/idb/build/esm/wrap-idb-value.js","webpack://7dtd-map/./node_modules/idb/build/esm/index.js","webpack://7dtd-map/./src/lib/map-storage.ts","webpack://7dtd-map/./src/lib/map.ts","webpack://7dtd-map/./src/lib/throttled-invoker.ts","webpack://7dtd-map/./src/lib/utils.ts","webpack://7dtd-map/./src/map-renderer.ts","webpack://7dtd-map/webpack/bootstrap","webpack://7dtd-map/webpack/runtime/define property getters","webpack://7dtd-map/webpack/runtime/hasOwnProperty shorthand","webpack://7dtd-map/webpack/runtime/make namespace object","webpack://7dtd-map/webpack/startup"],"names":["idbProxyableTypes","cursorAdvanceMethods","cursorRequestMap","WeakMap","transactionDoneMap","transactionStoreNamesMap","transformCache","reverseTransformCache","idbProxyTraps","target","prop","receiver","IDBTransaction","get","objectStoreNames","undefined","objectStore","wrap","set","value","has","transformCachableValue","func","IDBDatabase","prototype","transaction","IDBCursor","advance","continue","continuePrimaryKey","includes","args","apply","unwrap","this","storeNames","tx","call","sort","done","Promise","resolve","reject","unlisten","removeEventListener","complete","error","DOMException","addEventListener","cacheDonePromiseForTransaction","object","IDBObjectStore","IDBIndex","some","c","Proxy","IDBRequest","request","promise","success","result","then","catch","promisifyRequest","newValue","openDB","name","version","blocked","upgrade","blocking","terminated","indexedDB","open","openPromise","event","oldVersion","newVersion","db","deleteDB","deleteDatabase","readMethods","writeMethods","cachedMethods","Map","getMethod","targetFuncName","replace","useIndex","isWrite","method","async","storeName","store","index","shift","all","oldTraps","DEFAULT_WORLD_NAME","dbUpgrade","createObjectStore","keyPath","autoIncrement","createMap","id","put","getDb","self","_db","isLargeObjectType","type","LARGE_OBJECT_TYPES","changeMap","mapId","currentId","map","getAll","newMap","listeners","data","Error","requireNonnull","mapIdOrUndefined","delete","t","fn","markChar","putText","ctx","text","x","z","size","lineWidth","Math","round","strokeStyle","strokeText","fillText","canvas","fontFace","showBiomes","showSplat3","showSplat4","showRad","showPrefabs","biomesImg","splat3Img","splat4Img","radImg","brightness","scale","signSize","prefabs","FontFace","load","ff","fonts","add","markCoords","throttledUpdater","updateImmediately","max","width","height","console","time","timeEnd","context","getContext","filter","drawImage","imageSmoothingEnabled","font","family","fillStyle","textAlign","textBaseline","offsetX","offsetY","charOffsetX","charOffsetY","i","length","prefab","drawPrefabs","drawMark","asyncFunc","updateRequest","workerPromise","waitAnimationFrame","message","requireType","o","document","getElementById","e","lastChild","removeChild","d","toFixed","r","requestAnimationFrame","FIELDNAME_STORAGENAME_MAP","storage","MapStorage","init","log","fieldName","Object","entries","obj","getCurrent","update","push","onmessage","inMessage","assign","entry","postMessage","mapSizes","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","definition","key","defineProperty","enumerable","hasOwnProperty","Symbol","toStringTag"],"mappings":"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","file":"map-renderer.js","sourcesContent":["const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    promise\n        .then((value) => {\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n            cursorRequestMap.set(value, request);\n        }\n        // Catching to avoid \"Uncaught Promise exceptions\"\n    })\n        .catch(() => { });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Polyfill for objectStoreNames because of Edge.\n            if (prop === 'objectStoreNames') {\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\n            }\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n    if (func === IDBDatabase.prototype.transaction &&\n        !('objectStoreNames' in IDBTransaction.prototype)) {\n        return function (storeNames, ...args) {\n            const tx = func.call(unwrap(this), storeNames, ...args);\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n            return wrap(tx);\n        };\n    }\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(cursorRequestMap.get(this));\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\nexport { reverseTransformCache as a, instanceOfAny as i, replaceTraps as r, unwrap as u, wrap as w };\n","import { w as wrap, r as replaceTraps } from './wrap-idb-value.js';\nexport { u as unwrap, w as wrap } from './wrap-idb-value.js';\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction));\n        });\n    }\n    if (blocked)\n        request.addEventListener('blocked', () => blocked());\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking)\n            db.addEventListener('versionchange', () => blocking());\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked)\n        request.addEventListener('blocked', () => blocked());\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nexport { deleteDB, openDB };\n","import { DBSchema, IDBPDatabase, openDB } from \"idb\";\nimport { requireNonnull } from \"./utils\";\n\nconst DB_NAME = \"7dtd-map\";\nconst DB_VERSION = 2;\nconst DEFAULT_WORLD_NAME = \"New-World\";\n\ntype Db = IDBPDatabase<DbSchema>;\ninterface DbSchema extends DBSchema {\n  maps: {\n    value: MapObject;\n    key: number;\n  };\n  largeObjects: {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    value: LargeObject<any>;\n    key: [number, string];\n  };\n  selectedMap: {\n    value: { id: number; mapId: number };\n    key: number;\n  };\n}\n\nexport interface MapObject {\n  id: number;\n  name: string;\n}\n\nexport const LARGE_OBJECT_TYPES = [\n  \"biomes\",\n  \"splat3\",\n  \"splat4\",\n  \"rad\",\n  \"elevations\",\n  \"subElevations\",\n  \"prefabs\",\n  \"generationInfo\",\n] as const;\ntype LargeObjectType = typeof LARGE_OBJECT_TYPES[number];\nexport interface LargeObjects {\n  biomes: ImageBitmap;\n  splat3: ImageBitmap;\n  splat4: ImageBitmap;\n  rad: ImageBitmap;\n  elevations: Uint8Array;\n  subElevations: Uint8Array;\n  prefabs: Prefab[];\n  generationInfo: string;\n}\nexport interface LargeObject<T extends LargeObjectType> {\n  mapId: number;\n  type: T;\n  data: LargeObjects[T];\n}\n\nconst MAP_PROPERTY_TYPES = [\"maps\", ...LARGE_OBJECT_TYPES] as const;\ntype MapPropertyType = typeof MAP_PROPERTY_TYPES[number];\ntype MapPropertyValue<T extends MapPropertyType> = T extends LargeObjectType ? LargeObject<T> : DbSchema[\"maps\"][\"value\"];\ntype MapPropertyRawValue<T extends MapPropertyType> = T extends LargeObjectType\n  ? LargeObject<T>[\"data\"]\n  : DbSchema[\"maps\"][\"value\"][\"name\"];\n\nfunction dbUpgrade(db: Db, oldVersion: number, newVersion: number) {\n  for (let version = oldVersion + 1; version <= newVersion; version++) {\n    if (version === 1) {\n      db.createObjectStore(\"maps\", { keyPath: \"id\", autoIncrement: true });\n      db.createObjectStore(\"largeObjects\", { keyPath: [\"mapId\", \"type\"] });\n    }\n    if (version === 2) {\n      db.createObjectStore(\"selectedMap\", { keyPath: \"id\" });\n    }\n  }\n}\n\nexport class MapStorage {\n  _db?: Db;\n  listeners: ((mapId: number) => Promise<void>)[] = [];\n\n  async put<Type extends MapPropertyType>(type: Type, data: MapPropertyRawValue<Type>): Promise<void> {\n    const db = await getDb(this);\n    const mapId = await currentId(db);\n    if (isLargeObjectType(type)) {\n      await db.put(\"largeObjects\", { mapId, type, data });\n    } else if (type === \"maps\") {\n      await db.put(\"maps\", { id: mapId, name: data as MapPropertyRawValue<\"maps\"> });\n    } else {\n      throw Error(`Unreachable code: type=${type}`);\n    }\n  }\n\n  async getCurrent<Type extends MapPropertyType>(type: Type): Promise<MapPropertyValue<Type> | undefined> {\n    const db = await getDb(this);\n    const mapId = await currentId(db);\n    if (isLargeObjectType(type)) {\n      return (await db.get(\"largeObjects\", [mapId, type])) as MapPropertyValue<Type> | undefined;\n    } else if (type === \"maps\") {\n      return requireNonnull(await db.get(\"maps\", mapId), () => `Unexpected state: ${mapId}`) as MapPropertyValue<Type> | undefined;\n    } else {\n      throw Error(`Unreachable code: ${type}`);\n    }\n  }\n\n  async listMaps(): Promise<MapObject[]> {\n    const db = await getDb(this);\n    return db.getAll(\"maps\");\n  }\n\n  async createMap(name = DEFAULT_WORLD_NAME): Promise<MapObject> {\n    const db = await getDb(this);\n    return await createMap(db, name);\n  }\n\n  async deleteMap(mapIdOrUndefined?: number): Promise<void> {\n    const db = await getDb(this);\n    const mapId = mapIdOrUndefined ?? (await currentId(db));\n    await Promise.all([db.delete(\"maps\", mapId), ...LARGE_OBJECT_TYPES.map((t) => db.delete(\"largeObjects\", [mapId, t]))]);\n  }\n\n  async changeMap(mapId: number): Promise<void> {\n    const db = await getDb(this);\n    await Promise.all([changeMap(db, mapId), ...this.listeners.map((fn) => fn(mapId))]);\n  }\n\n  async currentId(): Promise<number> {\n    return currentId(await getDb(this));\n  }\n}\n\nasync function createMap(db: Db, name: string) {\n  const id = await db.put(\"maps\", { name } as MapObject);\n  return { id, name };\n}\n\nasync function getDb(self: MapStorage) {\n  if (!self._db) {\n    self._db = await openDB<DbSchema>(DB_NAME, DB_VERSION, { upgrade: dbUpgrade });\n  }\n  return self._db;\n}\n\nfunction isLargeObjectType(type: MapPropertyType): type is LargeObjectType {\n  return (LARGE_OBJECT_TYPES as readonly string[]).includes(type);\n}\n\nasync function changeMap(db: Db, mapId: number) {\n  await db.put(\"selectedMap\", { id: 0, mapId });\n}\n\nexport function isDefaultWorldName(name: string): boolean {\n  return name === DEFAULT_WORLD_NAME;\n}\n\nasync function currentId(db: Db): Promise<number> {\n  const map = await db.get(\"selectedMap\", 0);\n  if (map) {\n    return map.mapId;\n  }\n\n  const all = await db.getAll(\"maps\");\n  if (all[0]) {\n    await changeMap(db, all[0].id);\n    return currentId(db);\n  }\n\n  const newMap = await createMap(db, DEFAULT_WORLD_NAME);\n  await changeMap(db, newMap.id);\n  return currentId(db);\n}\n","import { FontFaceSet } from \"css-font-loading-module\";\nimport throttledInvoker from \"./throttled-invoker\";\n\nconst signChar = \"âœ˜\";\nconst markChar = \"ðŸš©ï¸\";\n\ndeclare const fonts: FontFaceSet;\n\nexport default class GameMap {\n  biomesImg: ImageBitmap | null;\n  brightness: string;\n  canvas: OffscreenCanvas;\n  fontFace: FontFace | null = null;\n  throttledUpdater: () => Promise<void>;\n  markCoords: Coords | null;\n  prefabs: HighlightedPrefab[];\n  radImg: ImageBitmap | null;\n  scale: number;\n  showBiomes: boolean;\n  showPrefabs: boolean;\n  showRad: boolean;\n  showSplat3: boolean;\n  showSplat4: boolean;\n  signSize: number;\n  splat3Img: ImageBitmap | null;\n  splat4Img: ImageBitmap | null;\n\n  constructor(canvas: OffscreenCanvas) {\n    this.canvas = canvas;\n    this.showBiomes = true;\n    this.showSplat3 = true;\n    this.showSplat4 = true;\n    this.showRad = true;\n    this.showPrefabs = true;\n    this.biomesImg = null;\n    this.splat3Img = null;\n    this.splat4Img = null;\n    this.radImg = null;\n    this.brightness = \"100%\";\n    this.scale = 0.1;\n    this.signSize = 200;\n    this.prefabs = [];\n\n    const fontFace = new FontFace(\"Noto Sans\", \"url(NotoEmoji-Regular.ttf)\");\n    fontFace.load().then((ff) => {\n      this.fontFace = ff;\n      fonts.add(ff);\n    });\n    this.markCoords = null;\n\n    this.throttledUpdater = throttledInvoker(() => this.updateImmediately());\n  }\n\n  get width(): number {\n    return Math.max(this.biomesImg?.width ?? 0, this.splat3Img?.width ?? 0, this.splat4Img?.width ?? 0);\n  }\n\n  get height(): number {\n    return Math.max(this.biomesImg?.height ?? 0, this.splat3Img?.height ?? 0, this.splat4Img?.height ?? 0);\n  }\n\n  async update(): Promise<void> {\n    console.time(\"Map Update\");\n    await this.throttledUpdater();\n    console.timeEnd(\"Map Update\");\n  }\n\n  async updateImmediately(): Promise<void> {\n    this.canvas.width = this.width * this.scale;\n    this.canvas.height = this.height * this.scale;\n\n    const context = this.canvas.getContext(\"2d\");\n    if (!context) return;\n    context.scale(this.scale, this.scale);\n    context.filter = `brightness(${this.brightness})`;\n    if (this.biomesImg && this.showBiomes) {\n      context.drawImage(this.biomesImg, 0, 0, this.width, this.height);\n    }\n    if (this.splat3Img && this.showSplat3) {\n      context.drawImage(this.splat3Img, 0, 0, this.width, this.height);\n    }\n    if (this.splat4Img && this.showSplat4) {\n      context.drawImage(this.splat4Img, 0, 0, this.width, this.height);\n    }\n    context.filter = \"none\";\n    if (this.radImg && this.showRad) {\n      context.imageSmoothingEnabled = false;\n      context.drawImage(this.radImg, 0, 0, this.width, this.height);\n      context.imageSmoothingEnabled = true;\n    }\n    if (this.showPrefabs) {\n      drawPrefabs(this, context);\n    }\n    if (this.markCoords) {\n      drawMark(this, context);\n    }\n  }\n}\n\nfunction drawPrefabs(map: GameMap, ctx: OffscreenCanvasRenderingContext2D) {\n  ctx.font = `${map.signSize}px ${map.fontFace?.family ?? \"\"}`;\n  ctx.fillStyle = \"red\";\n  ctx.textAlign = \"center\";\n  ctx.textBaseline = \"middle\";\n\n  const offsetX = map.width / 2;\n  const offsetY = map.height / 2;\n\n  const charOffsetX = Math.round(map.signSize * 0.01);\n  const charOffsetY = Math.round(map.signSize * 0.05);\n\n  // Inverted iteration to overwrite signs by higher order prefabs\n  for (let i = map.prefabs.length - 1; i >= 0; i -= 1) {\n    const prefab = map.prefabs[i];\n    const x = offsetX + prefab.x + charOffsetX;\n    // prefab vertical positions are inverted for canvas coodinates\n    const z = offsetY - prefab.z + charOffsetY;\n    putText(ctx, { text: signChar, x, z, size: map.signSize });\n  }\n}\n\nfunction drawMark(map: GameMap, ctx: OffscreenCanvasRenderingContext2D) {\n  if (!map.markCoords) return;\n\n  ctx.font = `${map.signSize}px ${map.fontFace?.family ?? \"\"}`;\n  ctx.fillStyle = \"red\";\n  ctx.textAlign = \"left\";\n  ctx.textBaseline = \"alphabetic\";\n\n  const offsetX = map.width / 2;\n  const offsetY = map.height / 2;\n  const charOffsetX = -1 * Math.round(map.signSize * 0.32);\n  const charOffsetY = -1 * Math.round(map.signSize * 0.1);\n\n  const x = offsetX + map.markCoords.x + charOffsetX;\n  // prefab vertical positions are inverted for canvas coodinates\n  const z = offsetY - map.markCoords.z + charOffsetY;\n\n  putText(ctx, { text: markChar, x, z, size: map.signSize });\n  ctx.strokeText(markChar, x, z);\n  ctx.fillText(markChar, x, z);\n}\n\ninterface MapSign {\n  text: string;\n  x: number;\n  z: number;\n  size: number;\n}\n\nfunction putText(ctx: OffscreenCanvasRenderingContext2D, { text, x, z, size }: MapSign) {\n  ctx.lineWidth = Math.round(size * 0.2);\n  ctx.strokeStyle = \"rgba(0, 0, 0, 0.8)\";\n  ctx.strokeText(text, x, z);\n\n  ctx.lineWidth = Math.round(size * 0.1);\n  ctx.strokeStyle = \"white\";\n  ctx.strokeText(text, x, z);\n\n  ctx.fillText(text, x, z);\n}\n","import { waitAnimationFrame } from \"./utils\";\n\nexport default function throttledInvoker(asyncFunc: () => Promise<void>): () => Promise<void> {\n  let updateRequest = null;\n  let workerPromise: Promise<void> | null = null;\n  return async () => {\n    updateRequest = true;\n\n    if (workerPromise) {\n      return;\n    }\n\n    workerPromise = (async () => {\n      while (updateRequest) {\n        updateRequest = false;\n        await asyncFunc();\n        await waitAnimationFrame();\n      }\n      workerPromise = null;\n    })();\n  };\n}\n","export function requireNonnull<T>(t: T | undefined | null, message = () => `Unexpected state: ${t}`): T {\n  if (t) return t;\n  else throw Error(message());\n}\n\nexport function requireType<T>(o: unknown, t: { new (...a: unknown[]): T }, message = () => `Unexpected type: ${o}`): T {\n  if (o instanceof t) return o;\n  throw Error(message());\n}\n\nexport function component<T extends HTMLElement>(id: string, t: { new (...a: unknown[]): T }): T {\n  return requireType(requireNonnull(document.getElementById(id)), t);\n}\n\nexport function removeAllChildren(e: HTMLElement): void {\n  while (e.lastChild) e.removeChild(e.lastChild);\n}\n\nexport function humanreadableDistance(d: number): string {\n  if (d < 1000) {\n    return `${d}m`;\n  }\n  return `${(d / 1000).toFixed(2)}km`;\n}\n\nexport function waitAnimationFrame(): Promise<number> {\n  return new Promise((r) => requestAnimationFrame(r));\n}\n","import GameMap from \"./lib/map\";\nimport { MapStorage } from \"./lib/map-storage\";\nimport { requireNonnull } from \"./lib/utils\";\n\nexport type MapRendererInMessage = Partial<\n  Pick<\n    GameMap,\n    | \"canvas\"\n    | \"biomesImg\"\n    | \"splat3Img\"\n    | \"splat4Img\"\n    | \"radImg\"\n    | \"showBiomes\"\n    | \"showSplat3\"\n    | \"showSplat4\"\n    | \"showRad\"\n    | \"showPrefabs\"\n    | \"brightness\"\n    | \"scale\"\n    | \"signSize\"\n    | \"prefabs\"\n    | \"markCoords\"\n  >\n>;\n\nexport interface MapRendererOutMessage {\n  mapSizes: { width: number; height: number };\n}\n\ndeclare function postMessage(message: MapRendererOutMessage): void;\n\nconst FIELDNAME_STORAGENAME_MAP = {\n  biomesImg: \"biomes\",\n  splat3Img: \"splat3\",\n  splat4Img: \"splat4\",\n  radImg: \"rad\",\n} as const;\n\nlet map: GameMap | null = null;\nconst storage = new MapStorage();\n\nstorage.listeners.push(async () => {\n  init();\n});\n\nonmessage = async (event) => {\n  const inMessage = event.data as MapRendererInMessage;\n  if (!map) {\n    if (inMessage.canvas) {\n      map = new GameMap(inMessage.canvas);\n      await init();\n    } else {\n      return;\n    }\n  }\n\n  await Object.assign(map, inMessage).update();\n  for (const entry of Object.entries(inMessage)) {\n    if (isStoreTarget(entry)) {\n      storage.put(FIELDNAME_STORAGENAME_MAP[entry[0]], entry[1]);\n    }\n  }\n  postMessage({\n    mapSizes: {\n      width: map.width,\n      height: map.height,\n    },\n  });\n};\n\nfunction isStoreTarget(e: Entry<MapRendererInMessage>): e is [keyof typeof FIELDNAME_STORAGENAME_MAP, ImageBitmap] {\n  return e[0] in FIELDNAME_STORAGENAME_MAP;\n}\n\nasync function init() {\n  console.log(\"init: Start\");\n  for (const [fieldName, type] of Object.entries(FIELDNAME_STORAGENAME_MAP)) {\n    console.time(`init: Load ${fieldName}`);\n    const obj = await storage.getCurrent(type);\n    requireNonnull(map)[fieldName] = obj?.data ?? null;\n    console.timeEnd(`init: Load ${fieldName}`);\n  }\n  await requireNonnull(map).update();\n  console.log(\"init: Done\");\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(496);\n"],"sourceRoot":""}